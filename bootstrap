#!/usr/bin/env bash
declare -i exitcode=0

# Debug prompt
export PS4="\e[1m==> \e[0m"

# Dotfiles information
DOTFILES_DIRECTORY="${HOME}/dotfiles"
DOTFILES_TARBALL_PATH="https://github.com/dhruvmanila/dotfiles/tarball/master"
DOTFILES_GIT_REMOTE="https://github.com/dhruvmanila/dotfiles"

# Install links
HOMEBREW_INSTALL_LINK="https://raw.githubusercontent.com/Homebrew/install/master/install.sh"
GIT_COMPLETION_PATH="/Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash"
GIT_COMPLETION_INSTALL_LINK="https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash"
VIM_PLUG_INSTALL_LINK="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"

# Colors
BOLD="\e[1m"
RESET_ALL="\e[0m"
GREEN="\e[32m"
RED="\e[35m"
YELLOW="\e[1;33m"


# ------------------------------------------------------------------ #
#                        Utility functions                           #
# ------------------------------------------------------------------ #

# Header logging
function header() {
    printf "\n%b==> %s %b\n" "$BOLD" "$@" "$RESET_ALL"
}

# Success logging
function success() {
    printf "%b✓ %s %b\n" "$GREEN" "$@" "$RESET_ALL"
}

# Error logging
function error() {
    printf "%b✗ %s %b\n" "$RED" "$@" "$RESET_ALL"
}

# Warning logging
function warning() {
    printf "%b! %s %b\n" "$YELLOW" "$@" "$RESET_ALL"
}

# Ask for confirmation before proceeding
function seek_confirmation() {
    printf "\n"
    warning "$@"
    read -rp "Continue? (y/n) " -n 1
    printf "\n"
}

# Test whether the result of an 'ask' is a confirmation
function is_confirmed() {
    if [[ "$REPLY" =~ ^[Yy]$ ]]; then
      return 0
    fi
    return 1
}

ask() {
  printf "%b[?] %s: %b" "$YELLOW" "$1" "$RESET_ALL"
  read -r
}

# Test whether we're in a git repo
function is_git_repo() {
    git rev-parse --is-inside-work-tree &> /dev/null
}

# Test whether a command exists
# $1 - cmd to test
function command_exists() {
    if command -v "$1" > /dev/null; then
      return 0
    fi
    return 1
}


# Make directory if it doesn't exist in $HOME
# $1 - directory to create
function mkdir_in_home() {
  if [[ ! -d "${HOME}/$1" ]]; then
    mkdir "${HOME}/$1"
  fi
}


# ------------------------------------------------------------------ #
#                          Check functions                           #
# ------------------------------------------------------------------ #

function check_dotfiles() {
  if [[ ! -d "${DOTFILES_DIRECTORY}" ]]; then
    header "Downloading dotfiles..."
    mkdir -p "${DOTFILES_DIRECTORY}"
    # Get the tarball
    if curl -fsSLo "${HOME}/dotfiles.tar.gz" "${DOTFILES_TARBALL_PATH}" > /dev/null; then
      success "Successfully downloaded the dotfiles."
    else
      error "Failed to download the dotfiles."
      exit 1
    fi
    # Extract to the dotfiles directory
    tar -zxf "${HOME}/dotfiles.tar.gz" --strip-components 1 -C "${DOTFILES_DIRECTORY}"
    if [[ -d "${DOTFILES_DIRECTORY}" ]]; then
      success "Successfully extracted the dotfiles."
    else
      error "Failed to extract the dotfiles."
      exit 1
    fi
    # Remove the tarball
    rm -rf "${HOME}/dotfiles.tar.gz"
  fi
}


function check_xcode_command_line_tools() {
  header "Checking for xcode command line tools..."
  if ! xcode-select -p &> /dev/null; then
    header "Installing xcode command line tools..."
    xcode-select --install > /dev/null
    # wait until the tools are installed...
    until xcode-select -p &> /dev/null; do
      sleep 5;
    done
    # making sure we installed it
    if xcode-select -p &> /dev/null; then
      success "Successfully installed xcode command line tools."
    else
      error "Failed to install xcode command line tools."
      exit 1
    fi
  else
    success "xcode command line tools already installed."
  fi
}


function check_homebrew() {
  header "Checking for homebrew..."
  if ! command_exists "brew"; then
    header "Installing Homebrew..."
    # Install performs `brew update` but the homebrew-core tap is a shallow clone
    # https://github.com/Homebrew/brew/pull/9447
    # So, if the command fails and if the repository is shallow, we will run the
    # recommended command
    if ! /bin/bash -c "$(curl -fsSL ${HOMEBREW_INSTALL_LINK})"; then
      error "Failure occured during installation. Checking if homebrew-core is a shallow clone..."
      if [[ -f "/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/.git/shallow" ]]; then
        header "Fetching everything from homebrew/homebrew-core (this may take a while)..."
        git -C "/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core" fetch --unshallow
      fi
    fi
    if command_exists 'brew'; then
      success "Successfully installed homebrew."
    else
      error "Failed to install homebrew."
      exit 1
    fi
  else
    success "Homebrew already installed."
  fi
  export HOMEBREW_NO_AUTO_UPDATE=1
  header "Updating Homebrew..."
  brew update && success "Done"
  header "Updating any existing Homebrew formulae..."
  brew upgrade && success "Done"

  header "Installing homebrew bundle tap..."
  brew tap homebrew/bundle && success "Done"
  header "Installing everything from Brewfile..."
  brew bundle install \
    --verbose \
    --no-lock \
    --cleanup \
    --file ~/dotfiles/lib/Brewfile \
    && success "Done"
  header "Cleaning up..."
  brew cleanup && success "Done"

  local brew_prefix
  brew_prefix=$(brew --prefix)
  if ! grep -F -q "${brew_prefix}/bin/bash" /etc/shells; then
    header "Switching to brew-installed bash as default shell..."
    echo "${brew_prefix}/bin/bash" | sudo tee -a /etc/shells;
    sudo chsh -s "${brew_prefix}/bin/bash";
    success "Done"
  fi;
}


function check_git() {
  header "Checking for git..."
  if ! command_exists "git"; then
    header "Updating Homebrew..."
    brew update
    header "Installing Git with Homebrew..."
    brew install git
    if command_exists "git"; then
      success "Successfully installed git."
    else
      error "Failed to install git."
      exit 1
    fi
  else
    success "Git already installed."
  fi
}


function check_git_repository() {
  header "Checking for git repository..."
  if ! is_git_repo; then
    header "Initializing git repository..."

    set -x
    git init
    git remote add origin "${DOTFILES_GIT_REMOTE}"
    git fetch --all
    git reset --hard FETCH_HEAD
    git clean -fd
    git pull --rebase --set-upstream origin master
    git submodule update --recursive --init
    set +x

    if is_git_repo; then
      success "Successfully initialized the git repository."
    else
      error "Failed to initialized the git repository."
      exit 1
    fi
  else
    success "Git repository already initialized."
  fi
}


function check_git_auto_completion() {
  header "Checking for git-completion..."
  if [[ ! -f $GIT_COMPLETION_PATH ]]; then
    if [[ ! -f "${HOME}/.git-completion.bash" ]]; then
      curl -fsSL $GIT_COMPLETION_INSTALL_LINK -o "${HOME}/.git-completion.bash"
      if [[ -f "${HOME}/.git-completion.bash" ]]; then
        success "Successfully downloaded git completion for bash."
      else
        error "Failed to download git completion for bash."
        exitcode=1
      fi
    else
      success "Git completion already downloaded."
    fi
  else
    success "Source git completion from ${GIT_COMPLETION_PATH}"
  fi
}


function check_python() {
  if ! command_exists "pyenv"; then
    error "pyenv is not installed. Make sure pyenv and its dependencies are installed."
    exit 1
  fi

  local pyenv_global_python="3.9.1"
  header "Checking for Python..."
  if [[ "$(pyenv global)" != "${pyenv_global_python}" ]]; then
    header "Installing Python ${pyenv_global_python}..."
    pyenv install --skip-existing ${pyenv_global_python}
    header "Making ${pyenv_global_python} as the global Python version..."
    pyenv global ${pyenv_global_python} && success "Done."
  fi
  header "Rehashing pyenv shims..."
  pyenv rehash && success "Done."

  local pip_exec
  pip_exec="$(pyenv root)/versions/${pyenv_global_python}/bin/pip"
  header "Upgrading pip..."
  $pip_exec install --upgrade pip

  header "Collecting packages from ${DOTFILES_DIRECTORY}/lib/requirements.txt..."
  local -a pip_packages
  while IFS= read -r line; do
    pip_packages+=("$line");
  done < "${DOTFILES_DIRECTORY}/lib/requirements.txt"
  success "Collected ${#pip_packages[@]} packages."

  header "Installing/Upgrading collected packages..."
  for package in "${pip_packages[@]}"; do
    header "Installing/Upgrading ${package}..."
    if $pip_exec install --upgrade "${package}"; then
      success "Successfully installed ${package}."
    else
      error "Failed to install ${package}."
      exitcode=1
    fi
  done
}


# ------------------------------------------------------------------ #
#               Check functions relying on dotfiles                  #
# ------------------------------------------------------------------ #

function check_vim_plug() {
  header "Checking for vim-plug..."
  if [[ ! -f "${DOTFILES_DIRECTORY}/vim/autoload/plug.vim" ]]; then
    curl -fsSLo ~/.vim/autoload/plug.vim --create-dirs $VIM_PLUG_INSTALL_LINK
    if [[ -f "${HOME}/.vim/autoload/plug.vim" ]]; then
      success "Successfully downloaded vim-plug."
    else
      error "Failed to download vim-plug."
      exitcode=1
    fi
  else
    success "Vim-plug already downloaded."
  fi
}


function check_ssh() {
  header "Checking for SSH keys..."
  if [[ ! -d "${HOME}/.ssh" ]]; then
    mkdir "${HOME}/.ssh" && success "Created ~/.ssh directory."
    link "assets/ssh/config" ".ssh/config"
  fi

  local ssh_algorithm="ed25519"
  if [[ -f "${HOME}/.ssh/id_${ssh_algorithm}.pub" ]]; then
    ssh -T git@github.com &> /dev/null
    [[ $? -eq 1 ]] && success "GitHub SSH is already authenticated."
    return
  else
    warning "No SSH keys found."
  fi

  header "Generating SSH keys..."
  ask "Please provide an email address"
  ssh-keygen -t "$ssh_algorithm" -C "$REPLY"

  seek_confirmation "Do you want to add the SSH key to the ssh-agent?"
  if is_confirmed; then
    header "Adding SSH key to the ssh-agent..."
    eval "$(ssh-agent -s)"
    ssh-add -K "${HOME}/.ssh/id_${ssh_algorithm}"
  fi

  header "Adding public SSH key to the GitHub account..."
  pbcopy < "${HOME}/.ssh/id_${ssh_algorithm}.pub" \
    && success "Copied public SSH key to clipboard. Please add it to GitHub.com..."
  open "https://github.com/settings/ssh"
  for i in {1..6}; do
    ssh -T git@github.com &> /dev/null
    if [[ $? -eq 1 ]]; then
      success "Authentication successful."
      break
    else
      if [[ i -eq 6 ]]; then
        error "Exceeded max retries."
        warning "Authenticate using 'ssh -T git@github.com' command."
        break
      fi
      error "Failed to authenticate. Retrying in 5 seconds..."
    fi
    sleep 5
  done
}


# ------------------------------------------------------------------ #
#                         Symlink dotfiles                           #
# ------------------------------------------------------------------ #

function backup_dotfiles() {
  local backup_dir
  backup_dir="${HOME}/dotfiles_$(date +"%Y_%m_%dT%H_%M_%S").backup"
  mkdir "$backup_dir"
  header "Creating backup for any existing dotfiles..."

  for location in "${HOME}/.bash_profile" \
    "${HOME}/.bashrc" \
    "${HOME}/.gitconfig" \
    "${HOME}/.gnupg" \
    "${HOME}/.inputrc" \
    "${HOME}/.tmux.conf" \
    "${HOME}/.vim"; do
    if [[ -f $location || -d $location ]]; then
      mv "$location" "$backup_dir"
      success "Backup ${location}"
    fi
  done
  success "Created backup in ${backup_dir}"
}


function link() {
  # Force create/replace the symlink.
  header "Creating symlink to ${2} in ${HOME} directory..."
  if ln -fs "${DOTFILES_DIRECTORY}/${1}" "${HOME}/${2}"; then
    success "Successfully created symlink at ${HOME}/${2}"
    return 0
  else
    error "Failed to create symlink for ${1}"
    return 1
  fi
}


function mirror_files() {
  backup_dotfiles
  # all the private/extra files should go in a folder named 'private'
  if [[ -d "${DOTFILES_DIRECTORY}/private" ]]; then
    link "private/gitconfig"        ".gitconfig"
  fi

  # copy hushlogin as we are not going to be updating it
  cp "${DOTFILES_DIRECTORY}/assets/hushlogin" "${HOME}/.hushlogin"

  mkdir_in_home ".gnupg"
  mkdir_in_home ".ssh"
  mkdir_in_home ".config"

  # Create the necessary symbolic links between the `dotfiles` and `HOME`
  # directory. The `bashrc` sources other files directly from the
  # `dotfiles` repository.
  link "bash/bashrc"                ".bashrc"                || exitcode=1
  link "bash/bash_profile"          ".bash_profile"          || exitcode=1
  link "assets/inputrc"             ".inputrc"               || exitcode=1
  link "vim/vimrc"                  ".vimrc"                 || exitcode=1
  link "tmux/tmux.conf"             ".tmux.conf"             || exitcode=1
  link "assets/gitignore"           ".gitignore"             || exitcode=1
  link "vim"                        ".vim"                   || exitcode=1
  link "python/flake8"              ".config/flake8"         || exitcode=1
  link "python/pylintrc"            ".pylintrc"              || exitcode=1
  link "assets/gpg/gpg.conf"        ".gnupg/gpg.conf"        || exitcode=1
  link "assets/gpg/gpg-agent.conf"  ".gnupg/gpg-agent.conf"  || exitcode=1
  link "assets/ssh/config"          ".ssh/config"            || exitcode=1

  success "Dotfiles update complete!"
}


# ------------------------------------------------------------------ #
#                         MacOS settings                             #
# ------------------------------------------------------------------ #

function update_macos_settings() {
  header "Updating macos settings..."
  bash "${DOTFILES_DIRECTORY}/lib/osxdefaults"
}


function update_macos_dock() {
  if ! command_exists "dockutil"; then
    header "Installing dockutil..."
    brew install --formula dockutil
  fi
  header "Updating macos dock applications..."
  dockutil --remove all && success "Removed all applications"
  for app in "/Applications/Safari.app" \
    "/Applications/Firefox.app" \
    "/Applications/PyCharm CE.app" \
    "/Applications/Visual Studio Code.app" \
    "/Applications/iTerm.app" \
    "/System/Applications/Notes.app" \
    "/Applications/Mark Text.app" \
    "/System/Applications/Music.app" \
    "/System/Applications/Books.app" \
    "/Applications/Slack.app" \
    "/Applications/Discord.app"; do
    dockutil --add "$app" --section apps && success "Added ${app}"
  done
  dockutil \
    --add "${HOME}/Downloads" \
    --view grid \
    --display folder \
    --sort dateadded \
    --section others && success "Added ~/Downloads folder"
}


# ------------------------------------------------------------------ #
#                         Main entrypoint                            #
# ------------------------------------------------------------------ #

function main() {
  check_dotfiles

  header "Changing directory to ${DOTFILES_DIRECTORY}"
  cd "${DOTFILES_DIRECTORY}" || { error "Failed to change directory." >&2;exit 1; }
  success "Done"

  check_xcode_command_line_tools
  check_homebrew
  check_git
  check_git_repository
  check_git_auto_completion
  check_python

  seek_confirmation "Warning: This step may overwrite your existing dotfiles."
  if is_confirmed; then
    mirror_files
    header "Sourcing ~/.bash_profile..."
    # shellcheck source=./bash/bash_profile
    source "${HOME}/.bash_profile" &> /dev/null && success "Done."
  else
    printf "Continuing...\n"
  fi

  # These rely on the dotfiles
  if [[ -f "${HOME}/.vimrc" ]]; then
    check_vim_plug
  fi
  if [[ -f "${HOME}/.ssh/config" ]]; then
    check_ssh
  fi

  seek_confirmation "Warning: This step may modify your OS X system defaults."
  if is_confirmed; then
    update_macos_settings
    update_macos_dock
  else
    printf "Skipped osx settings update.\n"
  fi
}

main
exit ${exitcode}

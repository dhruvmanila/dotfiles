#!/usr/bin/env bash
set -e
exit_code=0

# dotfiles directory
declare DOTFILES_DIRECTORY="${HOME}/dotfiles"
declare DOTFILES_TARBALL_PATH="https://github.com/dhruvmanila/dotfiles/tarball/master"
declare DOTFILES_GIT_REMOTE="https://github.com/dhruvmanila/dotfiles"

# -----------------------------------------------------

# If missing, download and extract the dotfiles repository
if [ ! -d "${DOTFILES_DIRECTORY}" ]; then
    printf "\n$(tput setaf 7)Downloading dotfiles...\033[m\n"
    mkdir -p "${DOTFILES_DIRECTORY}"

    # Get the tarball
    if curl -fsSLo "${HOME}/dotfiles.tar.gz" "${DOTFILES_TARBALL_PATH}"; then
        printf "$(tput setaf 64)✓ Successfully downloaded the dotfiles $(tput sgr0)\n"
    else
        printf "$(tput setaf 1)x Failed to download the dotfiles $(tput sgr0)\n"
        exit 1
    fi

    # Extract to the dotfiles directory
    tar -zxf "${HOME}/dotfiles.tar.gz" --strip-components 1 -C "${DOTFILES_DIRECTORY}"
    if [ -d "${DOTFILES_DIRECTORY}" ]; then
        printf "$(tput setaf 64)✓ Successfully extracted the dotfiles $(tput sgr0)\n"
    else
        printf "$(tput setaf 1)x Failed to extract the dotfiles $(tput sgr0)\n"
        exit 1
    fi

    # Remove the tarball
    rm -rf "${HOME}/dotfiles.tar.gz"
fi

# ----------------------------------------------------

source "${DOTFILES_DIRECTORY}/lib/utils" || exit 1
source "${DOTFILES_DIRECTORY}/lib/brew"  || exit 1

# change to the dotfiles directory
# For some unknown reason it doesn't exist, exit!
e_header "Changing to the ${DOTFILES_DIRECTORY} directory"
cd "${DOTFILES_DIRECTORY}" || exit 1
e_success "Done"

# ----------------------------------------------------

# Before relying on Homebrew, check that packages can be compiled by making sure
e_header "Checking for xcode command line tools..."
if ! xcode-select -p > /dev/null; then
    printf "Installing xcode command line tools...\n"
    xcode-select --install > /dev/null

    # wait until the tools are installed...
    until xcode-select -p > /dev/null; do
        sleep 5;
    done
    # making sure we installed it
    if type_exists 'gcc'; then
        e_success "Successfully installed xcode command line tools."
    else
        e_error "Failed to install xcode command line tools."
        exit 1
    fi
else
    e_success "xcode command line tools already installed."
fi

# ----------------------------------------------------

# Check for Homebrew
# Install homebrew and all the requested packages
e_header "Checking for homebrew..."
if ! type_exists 'brew'; then
    e_header "Installing Homebrew..."
    bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
    if type_exists 'brew'; then
        e_success "Successfully installed homebrew"
        e_header "Installing packages..."
        run_brew
    else
        e_error "Failed to install homebrew."
        exit 1
    fi
else
    e_success "Homebrew already installed."
    e_header "Updating packages..."
    run_brew
fi

# ----------------------------------------------------

# Check for git
# Git will be installed with xcode command line tools. If not
# then install with homebrew
e_header "Checking for git..."
if ! type_exists 'git'; then
    e_header "Updating Homebrew..."
    brew update > /dev/null
    e_success "Homebrew updated"
    e_header "Installing Git..."
    brew install git
    if type_exists 'git'; then
        e_success "Successfully installed git."
    else
        e_error "Failed to install git."
        exit 1
    fi
else
    e_success "Git already installed."
fi

# ----------------------------------------------------

# Initialize the git repository if it's missing
# Necessary only if it's a fresh install
if ! is_git_repo; then

    e_header "Initializing git repository..."
    git init -q || exit 1
    e_success "Initialized git repository"
    git remote add origin "${DOTFILES_GIT_REMOTE}" > /dev/null
    e_success "Added the remote repository as origin"
    git fetch -q --all || exit 1
    e_success "Fetched everything from the remote"
    git reset -q --hard FETCH_HEAD || exit 1
    e_success "Reset HEAD branch to master"
    git clean -qfd || exit 1
    e_success "Cleaned up untracked files"
    git pull -q --rebase --set-upstream origin master || exit 1
    e_success "Pulled down all the files from the remote"
    git submodule -q update --recursive --init || exit 1
    e_success "Initialized and updated all the submodules"

    e_header "Checking for git repository..."
    if is_git_repo; then
        e_success "Successfully initialized the git repository"
    else
        e_error "Failed to initialized the git repository"
        exit 1
    fi
fi


# ----------------------------------------------------

# Download Git Auto-Completion
e_header "Checking for git-completion..."
if [ ! -e "${HOME}/.git-completion.bash" ]; then
    curl -fsSL https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o "${HOME}/.git-completion.bash"
    if [ -f "${HOME}/.git-completion.bash" ]; then
        e_success "Successfully downloaded git completion for bash."
    else
        e_error "Failed to download git completion for bash."
        exit_code=1
    fi
else
    e_success "Git completion already downloaded."
fi

# ----------------------------------------------------


# Download vim plugin manager
e_header "Checking for vim-plug..."
if [ ! -e "${HOME}/dotfiles/vim/autoload" ]; then
    curl -fsSLo ~/.vim/autoload/plug.vim --create-dirs \
        https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    if [ -f "${HOME}/.vim/autoload/plug.vim" ]; then
        e_success "Successfully downloaded vim-plug. Use :PlugInstall to install the plugins."
    else
        e_error "Failed to download vim-plug."
        exit_code=1
    fi
else
    e_success "Vim-plug already downloaded. Use :PlugInstall to install the plugins."
fi


# ----------------------------------------------------

link() {

    # Force create/replace the symlink.
    e_header "Creating symlink to ${2} in ${HOME} directory..."
    if ln -fs "${DOTFILES_DIRECTORY}/${1}" "${HOME}/${2}"; then
        e_success "Successfully created symlink at ${HOME}/${2}"
        return 0
    else
        e_error "Failed to create symlink for ${1}"
        return 1
    fi
}

# ----------------------------------------------------


mirrorfiles() {
    # all the private/extra files should go in a folder named 'private'
    if [ -d "${DOTFILES_DIRECTORY}/private" ]; then
        link "private/gitconfig"      ".gitconfig"
    fi

    # copy hushlogin as we are not going to be updating it
    cp "${DOTFILES_DIRECTORY}/assets/hushlogin" "${HOME}/.hushlogin"

    # Force remove the vim directory if it's already there.
    if [ -e "${HOME}/.vim" ]; then
        rm -rf "${HOME}/.vim"
    fi

    # Create the necessary symbolic links between the `dotfiles` and `HOME`
    # directory. The `bash_profile` sources other files directly from the
    # `dotfiles` repository.
    link "bash/bashrc"         ".bashrc"           || exit 1
    link "bash/bash_profile"   ".bash_profile"     || exit 1
    link "assets/inputrc"      ".inputrc"          || exit 1
    link "vim/vimrc"           ".vimrc"            || exit 1
    link "tmux/tmux.conf"      ".tmux.conf"        || exit 1
    link "assets/gitignore"    ".gitignore"        || exit 1
    link "vim"                 ".vim"              || exit 1

    e_success "Dotfiles update complete!"
}

# ----------------------------------------------------

# Ask before potentially overwriting files
seek_confirmation "Warning: This step may overwrite your existing dotfiles."

if is_confirmed; then
    mirrorfiles
    source "${HOME}/.bash_profile"
else
    printf "Continuing...\n"
fi


# ----------------------------------------------------

# Ask before potentially overwriting OS X defaults
seek_confirmation "Warning: This step may modify your OS X system defaults."

if is_confirmed; then
    bash "${DOTFILES_DIRECTORY}/lib/osxdefaults"
    e_success "OS X settings updated! You may need to restart."
else
    printf "Skipped OS X settings update.\n"
fi

# ----------------------------------------------------
exit $exit_code


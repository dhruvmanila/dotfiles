#!/usr/bin/env bash
declare -i exitcode=0

# Debug prompt
export PS4="\e[1m==> \e[0m"

# Dotfiles information
DOTFILES_DIRECTORY="${HOME}/dotfiles"

# Colors
BOLD="\e[1m"
RESET_ALL="\e[0m"
GREEN="\e[32m"
RED="\e[31m"
YELLOW="\e[1;33m"


# ------------------------------------------------------------------ #
#                        Utility functions                           #
# ------------------------------------------------------------------ #

# Header logging
function header() {
  printf "\n%b==> %s %b\n" "$BOLD" "$@" "$RESET_ALL"
}

# Success logging
function success() {
  printf "%b✓ %s %b\n" "$GREEN" "$@" "$RESET_ALL"
}

# Error logging
function error() {
  printf "%b✗ %s %b\n" "$RED" "$@" "$RESET_ALL"
}

# Warning logging
function warning() {
  printf "%b! %s %b\n" "$YELLOW" "$@" "$RESET_ALL"
}

# Ask for confirmation before proceeding
function seek_confirmation() {
  printf "\n"
  warning "$@"
  read -rp "Continue? (y/n) " -n 1
  printf "\n"
}

# Test whether the result of an 'ask' is a confirmation
function is_confirmed() {
  if [[ "$REPLY" =~ ^[Yy]$ ]]; then
    return 0
  fi
  return 1
}

# Ask the user for some information
function ask() {
  printf "%b[?] %s: %b" "$YELLOW" "$1" "$RESET_ALL"
  read -r
}

# Test whether we're in a git repo
function is_git_repo() {
  git rev-parse --is-inside-work-tree &> /dev/null
}

# Test whether a command exists
# $1 - cmd to test
function command_exists() {
  if command -v "$1" > /dev/null; then
    return 0
  fi
  return 1
}


# Make directory if it doesn't exist in $HOME
# $1 - directory to create
function mkdir_in_home() {
  if [[ ! -d "${HOME}/$1" ]]; then
    mkdir "${HOME}/$1"
  fi
}


# ------------------------------------------------------------------ #
#                          Check functions                           #
# ------------------------------------------------------------------ #

function check_dotfiles() {
  if [[ ! -d "${DOTFILES_DIRECTORY}" ]]; then
    header "Downloading dotfiles..."
    mkdir -p "${DOTFILES_DIRECTORY}"
    # Get the tarball
    if curl -fsSLo ~/dotfiles.tar.gz https://github.com/dhruvmanila/dotfiles/tarball/master; then
      success "Successfully downloaded the dotfiles."
    else
      error "Failed to download the dotfiles."
      exit 1
    fi
    # Extract to the dotfiles directory
    tar -zxf "${HOME}/dotfiles.tar.gz" --strip-components 1 -C "${DOTFILES_DIRECTORY}"
    if [[ -d "${DOTFILES_DIRECTORY}" ]]; then
      success "Successfully extracted the dotfiles."
    else
      error "Failed to extract the dotfiles."
      exit 1
    fi
    # Remove the tarball
    rm -rf ~/dotfiles.tar.gz
  fi
}


function check_xcode_command_line_tools() {
  header "Checking for xcode command line tools..."
  if ! xcode-select -p &> /dev/null; then
    warning "xcode command line tools are not installed"
    header "Installing xcode command line tools..."
    xcode-select --install > /dev/null
    # wait until the tools are installed...
    until xcode-select -p &> /dev/null; do
      sleep 5;
    done
    # making sure we installed it
    if xcode-select -p &> /dev/null; then
      success "Successfully installed xcode command line tools."
    else
      error "Failed to install xcode command line tools."
      exit 1
    fi
  else
    success "xcode command line tools are already installed."
  fi
}


function check_homebrew_shallow() {
  # https://github.com/Homebrew/brew/pull/9383
  local core_location="/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core"
  local cask_location="/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask"

  header "Checking if homebrew-core is a shallow clone..."
  if [[ -f "${core_location}/.git/shallow" ]]; then
    warning "homebrew/homebrew-core is a shallow clone."
    header "Fetching everything from homebrew/homebrew-core (this may take a while)..."
    git -C $core_location fetch --unshallow
  else
    success "homebrew/homebrew-core is not a shallow clone."
  fi
  # homebrew-cask might not be installed
  if [[ -d "${cask_location}" ]]; then
    header "Checking if homebrew-cask is a shallow clone..."
    if [[ -f "${cask_location}/.git/shallow" ]]; then
      warning "homebrew/homebrew-cask is a shallow clone."
      header "Fetching everything from homebrew/homebrew-cask (this may take a while)..."
      git -C $cask_location fetch --unshallow
    else
      success "homebrew/homebrew-cask is not a shallow clone."
    fi
  fi
}


function check_homebrew() {
  header "Checking for homebrew..."
  if ! command_exists "brew"; then
    warning "Homebrew is not installed."
    header "Installing Homebrew..."
    # Install performs `brew update` but the homebrew-core tap is a shallow clone
    # https://github.com/Homebrew/brew/pull/9447
    # So, if the command fails and if the repository is shallow, we will run the
    # recommended command
    if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"; then
      error "Failure occured during Homebrew installation."
      check_homebrew_shallow
    fi

    { command_exists 'brew' && success "Successfully installed Homebrew."; } \
      || { error "Failed to install Homebrew." >&2; exit 1;}
  else
    success "Homebrew already installed."
  fi
  # No auto update during the setup process
  export HOMEBREW_NO_AUTO_UPDATE=1

  # Shallow clone error will occur only when updating Homebrew
  header "Updating Homebrew..."
  { brew update && success "Done"; } \
    || { error "Failed to update Homebrew."; check_homebrew_shallow; }

  header "Updating any existing Homebrew formulas..."
  { brew upgrade && success "Done"; } \
    || { error "Failed to upgrade Homebrew formulas."; exitcode=1; }

  # If the bundle installation fails, then exit as we won't be able to install
  # anything using the Brewfile
  header "Installing homebrew bundle tap..."
  { brew tap homebrew/bundle && success "Done."; } \
    || { error "Failed to install homebrew/bundle tap." >&2; exit 1; }

  header "Installing everything from Brewfile..."
  # -v: prints output from commands as they are run
  # --no-lock: don't output a Brewfile.lock.json file
  { brew bundle install -v --no-lock --file ~/dotfiles/lib/Brewfile && success "Done"; } \
    || { error "Failure occured during 'brew bundle install'"; exitcode=1; }

  header "Cleaning up..."
  { brew cleanup && success "Done"; } \
    || { error "Failure occured during 'brew cleanup'"; exitcode=1; }

  local brew_prefix
  brew_prefix=$(brew --prefix)
  if ! grep -F -q "${brew_prefix}/bin/bash" /etc/shells; then
    header "Switching to brew-installed bash as default shell..."
    echo "${brew_prefix}/bin/bash" | sudo tee -a /etc/shells;
    { sudo chsh -s "${brew_prefix}/bin/bash" && success "Done"; } \
      || { error "Failed to change the default shell."; exitcode=1; }
  fi;
}


function check_git() {
  header "Checking for Git..."
  if ! command_exists "git"; then
    warning "Git is not installed"
    header "Installing Git with Homebrew..."
    brew install --formula git
    if command_exists "git"; then
      success "Successfully installed Git."
    else
      error "Failed to install Git."
      exit 1
    fi
  else
    success "Git is already installed."
  fi
}


function check_git_repository() {
  header "Checking for Git repository..."
  if ! is_git_repo; then
    warning "Git repository is not initialized."
    header "Initializing Git repository..."

    set -x
    git init                                                       || exitcode=1
    git remote add origin https://github.com/dhruvmanila/dotfiles  || exitcode=1
    git fetch --all                                                || exitcode=1
    git reset --hard FETCH_HEAD                                    || exitcode=1
    git branch --set-upstream-to origin/master master              || exitcode=1
    set +x

    if is_git_repo; then
      success "Successfully initialized the Git repository."
    else
      error "Failed to initialized the Git repository."
      exitcode=1
    fi
  else
    success "Git repository is already initialized."
  fi
}


function check_python() {
  if ! command_exists "pyenv"; then
    error "pyenv is not installed. Install it using 'brew install --formula pyenv' command."
    exit 1
  fi

  local pyenv_global_python="3.9.1"
  header "Checking for Python ${pyenv_global_python}..."
  if ! pyenv versions | grep -q ${pyenv_global_python}; then
    warning "Python ${pyenv_global_python} is not installed"
    header "Installing Python ${pyenv_global_python}..."
    if pyenv install ${pyenv_global_python}; then
      success "Successfully installed Python ${pyenv_global_python}"
    else
      error "Failure occured while installing Python ${pyenv_global_python}"
      return
    fi
  else
    success "Python ${pyenv_global_python} is already installed"
  fi

  if [[ $(pyenv global) != "$pyenv_global_python" ]]; then
    header "Making ${pyenv_global_python} as the global Python version..."
    pyenv global ${pyenv_global_python} && success "Done."
  fi

  header "Rehashing pyenv shims..."
  pyenv rehash && success "Done."

  local pip_exec
  pip_exec="$(pyenv root)/versions/${pyenv_global_python}/bin/pip"
  header "Upgrading pip..."
  $pip_exec install --upgrade pip

  header "Collecting packages from ${DOTFILES_DIRECTORY}/lib/requirements.txt..."
  local -a pip_packages
  while IFS= read -r line; do
    pip_packages+=("$line");
  done < "${DOTFILES_DIRECTORY}/lib/requirements.txt"
  success "Collected ${#pip_packages[@]} packages."

  header "Installing collected packages..."
  for package in "${pip_packages[@]}"; do
    header "Installing ${package}..."
    if $pip_exec install --upgrade "${package}"; then
      success "Successfully installed ${package}."
    else
      error "Failed to install ${package}."
      exitcode=1
    fi
  done
}


# ------------------------------------------------------------------ #
#               Check functions relying on dotfiles                  #
# ------------------------------------------------------------------ #

function check_vim_plugins() {
  header "Checking for vim plugins..."
  if [[ ! -d "${HOME}/.vim/plugged" ]]; then
    warning "Vim plugins are not installed."
    header "Upgrading vim plug..."
    vim +PlugUpgrade +qa && success "Done."
    header "Installing vim plugins..."
    vim +PlugInstall +qa && success "Done."
  else
    success "Vim plugins are already installed."
    header "Upgrading vim plug..."
    vim +PlugUpgrade +qa && success "Done."
    header "Updating vim plugins..."
    vim +PlugUpdate +qa && success "Done."
  fi
}


function check_tmux_plugins() {
  header "Checking for tmux plugins..."
  if [[ ! -d "${HOME}/.tmux/plugins/tpm" ]]; then
    warning "tmux plugin manager is not installed."
    header "Installing tmux plugin manager..."
    if git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm; then
      success "Successfully installed tmux plugin manager."
      header "Installing tmux plugins..."
      { ~/.tmux/plugins/tpm/bin/install_plugins && success "Done."; } \
        || { error "Failed to install tmux plugins."; exitcode=1; }
    else
      error "Failed to install tmux plugin manager."
      exitcode=1
      return
    fi
  else
    success "tmux plugin manager is already installed."
    header "Updating tmux plugins..."
    { ~/.tmux/plugins/tpm/bin/update_plugins all && success "Done".; } \
      || { error "Failed to update tmux plugins."; exitcode=1; }
  fi
}


function check_github_ssh() {
  header "Checking for SSH keys..."
  if [[ ! -d "${HOME}/.ssh" ]]; then
    mkdir "${HOME}/.ssh" && success "Created ~/.ssh directory."
    link "assets/ssh/config" ".ssh/config"
  elif [[ ! -f "${HOME}/.ssh/config" ]]; then
    link "assets/ssh/config" ".ssh/config"
  fi

  local ssh_agent_env="${HOME}/.ssh/agent_env_${HOSTNAME}"
  local ssh_algorithm="ed25519"
  local ssh_filename="github"

  if [[ -f "${HOME}/.ssh/${ssh_filename}.pub" ]]; then
    ssh -T git@github.com &> /dev/null
    [[ $? -eq 1 ]] && success "GitHub SSH is already authenticated."
    return
  fi

  warning "SSH key file ~/.ssh/${ssh_filename}.pub not found."
  header "Generating SSH keys..."
  ask "Please provide an email address"
  ssh-keygen -f "${HOME}/.ssh/${ssh_filename}" -t "$ssh_algorithm" -C "$REPLY"

  header "Adding SSH key to the ssh-agent..."
  ssh-agent > "${ssh_agent_env}"
  success "Stored SSH agent information in ${ssh_agent_env}"
  # shellcheck disable=SC1090
  source "${ssh_agent_env}"
  ssh-add -K "${HOME}/.ssh/${ssh_filename}"

  header "Adding public SSH key to the GitHub account..."
  pbcopy < "${HOME}/.ssh/${ssh_filename}.pub" \
    && success "Copied public SSH key to clipboard. Please add it to GitHub.com..."
  open "https://github.com/settings/ssh"
  for i in {1..6}; do
    ssh -T git@github.com &> /dev/null
    if [[ $? -eq 1 ]]; then
      success "Authentication successful."
      break
    else
      if [[ i -eq 6 ]]; then
        error "Exceeded max retries. Authenticate using 'ssh -T git@github.com' command."
        break
      fi
      error "Failed to authenticate. Retrying in 5 seconds..."
    fi
    sleep 5
  done
}


# ------------------------------------------------------------------ #
#                         Symlink dotfiles                           #
# ------------------------------------------------------------------ #

function backup_dotfiles() {
  local backup_dir
  local -i count=0
  backup_dir="${HOME}/dotfiles_$(date +"%Y_%m_%dT%H_%M_%S").backup"
  mkdir "$backup_dir"

  header "Creating backup for any existing dotfiles..."
  for location in "${HOME}/.bash_profile" \
    "${HOME}/.bashrc" \
    "${HOME}/.gitconfig" \
    "${HOME}/.inputrc" \
    "${HOME}/.tmux.conf" \
    "${HOME}/.vim"; do
    if [[ -f $location || -d $location ]]; then
      mv "$location" "$backup_dir"
      success "Backup ${location}"
      (( count+=1 ))
    fi
  done

  if (( count > 0 )); then
    success "Created backup in ${backup_dir}"
  else
    success "Skipped backup as there are no dotfiles"
    rm -rf "$backup_dir"
  fi
}


function link() {
  # Force create/replace the symlink.
  header "Creating symlink to ${2} in ${HOME} directory..."
  if ln -fs "${DOTFILES_DIRECTORY}/${1}" "${HOME}/${2}"; then
    success "Successfully created symlink at ${HOME}/${2}"
    return 0
  else
    error "Failed to create symlink for ${1}"
    return 1
  fi
}


function mirror_files() {
  backup_dotfiles

  # copy hushlogin as we are not going to be updating it
  cp "${DOTFILES_DIRECTORY}/assets/hushlogin" "${HOME}/.hushlogin"

  mkdir_in_home ".gnupg"
  mkdir_in_home ".ssh"
  mkdir_in_home ".config"

  # Create the necessary symbolic links between the `dotfiles` and `HOME`
  # directory. The `bashrc` sources other files directly from the
  # `dotfiles` repository.
  link "bash/bashrc"                ".bashrc"                || exitcode=1
  link "bash/bash_profile"          ".bash_profile"          || exitcode=1
  link "vim/vimrc"                  ".vimrc"                 || exitcode=1
  link "vim"                        ".vim"                   || exitcode=1
  link "tmux/tmux.conf"             ".tmux.conf"             || exitcode=1
  link "python/flake8"              ".config/flake8"         || exitcode=1
  link "python/pylintrc"            ".pylintrc"              || exitcode=1
  link "assets/inputrc"             ".inputrc"               || exitcode=1
  link "assets/gitignore"           ".gitignore"             || exitcode=1
  link "assets/gitconfig"           ".gitconfig"             || exitcode=1
  link "assets/gpg/gpg.conf"        ".gnupg/gpg.conf"        || exitcode=1
  link "assets/gpg/gpg-agent.conf"  ".gnupg/gpg-agent.conf"  || exitcode=1
  link "assets/ssh/config"          ".ssh/config"            || exitcode=1
  link "mac/mackup.cfg"             ".mackup.cfg"            || exitcode=1
  link "mac/mackup"                 ".mackup"                || exitcode=1

  success "Dotfiles update complete."
}


# ------------------------------------------------------------------ #
#                         MacOS settings                             #
# ------------------------------------------------------------------ #

function update_macos_settings() {
  header "Updating macOS settings..."
  bash "${DOTFILES_DIRECTORY}/lib/osxdefaults"
}


function update_macos_dock() {
  if ! command_exists "dockutil"; then
    header "Installing dockutil..."
    brew install --formula dockutil
  fi

  header "Updating macOS dock applications..."
  dockutil --remove all && success "Removed all applications"
  for app in "/Applications/Safari.app" \
    "/Applications/Firefox.app" \
    "/Applications/Brave Browser.app" \
    "/Applications/PyCharm CE.app" \
    "/Applications/Visual Studio Code.app" \
    "/Applications/iTerm.app" \
    "/System/Applications/Notes.app" \
    "/Applications/Mark Text.app" \
    "/System/Applications/Music.app" \
    "/System/Applications/Books.app" \
    "/Applications/Slack.app" \
    "/Applications/Discord.app"; do
    if dockutil --add "$app" --section apps; then
      success "Added ${app}"
    else
      error "Failed to add ${app}"
      exitcode=1
    fi
  done

  { dockutil \
    --add "${HOME}/Downloads" \
    --view grid \
    --display folder \
    --sort dateadded \
    --section others && success "Added ~/Downloads folder"; } \
    || { error "Failed to add ~/Downloads folder"; exitcode=1; }
}


# ------------------------------------------------------------------ #
#                         Main entrypoint                            #
# ------------------------------------------------------------------ #

function main() {
  check_dotfiles

  header "Changing directory to ${DOTFILES_DIRECTORY}"
  cd "${DOTFILES_DIRECTORY}" || { error "Failed to change directory." >&2;exit 1; }
  success "Done."

  check_xcode_command_line_tools
  check_homebrew
  check_git
  check_git_repository
  check_python

  seek_confirmation "Warning: This step may overwrite your existing dotfiles."
  if is_confirmed; then
    mirror_files
  else
    success "Continuing..."
  fi

  # These rely on the dotfiles
  check_vim_plugins
  check_tmux_plugins
  check_github_ssh

  seek_confirmation "Warning: This step may modify your macOS system defaults."
  if is_confirmed; then
    update_macos_settings
    update_macos_dock
  else
    success "Skipped macOS settings update."
  fi
}

main
exit ${exitcode}

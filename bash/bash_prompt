#!/usr/bin/env bash


function __git_prompt() {
	local s='';
	local branch_name='';

	# Check if the current directory is in a Git repository.
	git rev-parse --is-inside-work-tree &>/dev/null || return;

	# Check for what branch we’re on.
	# Get the short symbolic ref. If HEAD isn’t a symbolic ref, get a
	# tracking remote branch or tag. Otherwise, get the
	# short SHA for the latest commit, or give up.
	branch_name="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
		git describe --all --exact-match HEAD 2> /dev/null || \
		git rev-parse --short HEAD 2> /dev/null || \
		echo '(unknown)')";

	# Early exit for Chromium & Blink repo, as the dirty check takes too long.
	# Thanks, @paulirish!
	# https://github.com/paulirish/dotfiles/blob/dd33151f/.bash_prompt#L110-L123
	repo_url="$(git config --get remote.origin.url)";
	if grep -q 'chromium/src.git' <<< "${repo_url}"; then
		s+='*';
	else
		# Check for uncommitted changes in the index.
		if ! git diff --quiet --ignore-submodules --cached; then
			s+='+';
		fi;

		# Check for unstaged changes.
		if ! git diff-files --quiet --ignore-submodules --; then
			s+='!';
		fi;

		# Check for untracked files.
		if [ -n "$(git ls-files --others --exclude-standard)" ]; then
			s+='?';
		fi;

		# Check for stashed files.
		if git rev-parse --verify refs/stash &>/dev/null; then
			s+='$';
		fi;
	fi;

	[ -n "${s}" ] && s=" [${s}]";

	echo -e "${1}${branch_name}${2}${s}";
}


function __build_prompt() {
  local EXIT="$?"

  local -r RESET="\[\e[0m\]";
  local -r RED="\[\e[0;31m\]";
  local -r GREEN="\[\e[0;32m\]";
  local -r YELLOW="\[\e[0;33m\]";
  local -r BLUE="\[\e[1;34m\]";
  local -r WHITE="\[\e[1;37m\]";

  PS1="\n"
  
  # Prompt - [exitcode] [(root)] [@hostname] pwd [on branch [status]]
  # Show the exit code if it is not 0
  if [[ $EXIT -ne 0 ]]; then
    PS1+="${RED}✗ ${EXIT} "
  fi

  # PS1+="${BLUE}\t: "

  # Show username only if its root
  if [[ $USER == "root" ]]; then
    PS1+="${WHITE}(${RED}\u${WHITE}) "
  fi

  # Show hostname only if its not local
  if [[ "${SSH_TTY}" ]]; then
    PS1+="${WHITE}@${BLUE}\h "
  fi

  # Working directory full path
  PS1+="${GREEN}\w"

  # Git repository details
  PS1+="\$(__git_prompt \"${WHITE} on ${YELLOW}\" \"${BLUE}\")";

  # Prompt character '$ '
  PS1+="\n${WHITE}\$ ${RESET}"

  # Continuition prompt
  PS2="\[${YELLOW}\]→ \[${RESET}\]";

  # Debug prompt
  PS4="\[${WHITE}\]==> \[${RESET}\]";

}


# Set the various prompt commands (PS1, PS2, PS4)
# Include previous values to maintain Apple Terminal support (window title path and sessions)
# This is explained in /etc/bashrc_Apple_Terminal
PROMPT_COMMAND="__build_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}"

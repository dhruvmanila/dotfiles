"
"               ██╗   ██╗██╗███╗   ███╗██████╗  ██████╗
"               ██║   ██║██║████╗ ████║██╔══██╗██╔════╝
"               ██║   ██║██║██╔████╔██║██████╔╝██║
"               ╚██╗ ██╔╝██║██║╚██╔╝██║██╔══██╗██║
"                ╚████╔╝ ██║██║ ╚═╝ ██║██║  ██║╚██████╗
"                 ╚═══╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝
"
" -----------------------------------------------------------------------------
" CONTENTS - Use '*' to jump to the location
"
" |vimrc_plugins|..................................Plugins
" |vimrc_editor_settings|..........................Editor Settings
"   |vimrc_general_settings|.......................General Settings
"   |vimrc_cursor_shape|...........................Cursor Shape
"   |vimrc_search_settings|........................Search Settings
" |vimrc_functions|................................Functions
" |vimrc_mappings|.................................Mappings
" |vimrc_commands|.................................Commands
" |vimrc_autocommands|.............................Autocommands
" |vimrc_plugin_config|............................Plugin Configuration
"   |vimrc_ale_config|.............................ALE
"   |vimrc_coc_config|.............................Conquer Of Completion
"     |vimrc_coc_control|..........................Coc control
"   |vimrc_color_scheme_config|....................Color Scheme
"   |vimrc_fugitive_config|........................Fugitive
"   |vimrc_incsearch_config|.......................Incsearch
"   |vimrc_indentline_config|......................Indentline
"   |vimrc_lightline_config|.......................Lightline
"   |vimrc_nerdcommenter_config|...................NERDCommenter
"   |vimrc_nerdtree_config|........................NERDTree
"   |vimrc_python_syntax_config|...................Python Syntax
"   |vimrc_startify_config|........................Startify
"   |vimrc_tmuxline_config|........................Tmuxline
"   |vimrc_vim_cool_config|........................Vim Cool
"   |vimrc_vim_external_config|....................Vim External
" |vimrc_set_color_scheme|.........................Set Vim Color Scheme
"
"
" NOTE:
" - Use '_' to separate words
" - Please keep the plugin configuration in alphabetical order


" Environment
" -----------------------------------------------------------------------------

" Leader is space
let g:mapleader=" "

" Available: 'vim-monokai-tasty', 'sonokai', 'gruvbox-material'
let g:vimrc_colors_name = 'gruvbox-material'

" Load Coc for specific filetypes or everytime
let g:keep_coc_in_control = 1

" Start Coc manually (takes precedence over keep_coc_in_control)
let g:coc_startup_manual_only = 1


" =============================================================================
" PLUGINS                                                       *vimrc_plugins*
" =============================================================================
" Ref: https://github.com/junegunn/vim-plug

call plug#begin('~/.vim/plugged')

" Colorschemes
Plug 'patstockwell/vim-monokai-tasty'
Plug 'sainnhe/sonokai'
Plug 'sainnhe/gruvbox-material'

" Search
Plug 'romainl/vim-cool'
Plug 'haya14busa/incsearch.vim'

" Auto-complete, linting, formatting and all the good stuff
Plug 'neoclide/coc.nvim', {'branch': 'release', 'on': 'CocStart'}
Plug 'dense-analysis/ale'

" Syntactic language support
Plug 'vim-python/python-syntax', {'for': 'python'}
Plug 'stephpy/vim-yaml', {'for': ['yaml', 'yml']}
Plug 'wlangstroth/vim-racket', {'for': 'racket'}
Plug 'jez/vim-better-sml', {'for': 'sml'}

" Text manipulations
Plug 'preservim/nerdcommenter'
" Plug 'tpope/vim-surround'

" GUI enhancements
Plug 'itchyny/lightline.vim'
Plug 'maximbaz/lightline-ale'
Plug 'mhinz/vim-startify'
Plug 'preservim/nerdtree'
Plug 'Yggdroot/indentLine'

" Git plugin
Plug 'tpope/vim-fugitive'

" Tmux
Plug 'hoov/tmuxline.vim', {'branch': 'truecolor-lightline', 'on': ['Tmuxline', 'TmuxlineSnapshot']}

" Others
" Plug 'tweekmonster/startuptime.vim', {'on': 'StartupTime'}
Plug 'itchyny/vim-external'
Plug 'dstein64/vim-startuptime', {'on': 'StartupTime'}

call plug#end()


" =============================================================================
" EDITOR SETTINGS                                       *vimrc_editor_settings*
" =============================================================================

" General Settings                                     *vimrc_general_settings*
" -----------------------------------------------------------------------------
" VI compatible mode is disabled so that VIm things work
set nocompatible

syntax on

filetype plugin indent on

if exists('+termguicolors')
  set termguicolors
  " The commands below are needed for tmux + termguicolors
  " This is only necessary if you use "set termguicolors".
  let &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
  let &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
endif

set ttyfast             " Improve redrawing
set lazyredraw

set nocursorline
set number              " show line numbers
" set relativenumber      " show relative numbering
set signcolumn=yes      " show sign column
set textwidth=0
set colorcolumn=80
set nowrap
set equalalways

set showcmd             " Show the command being typed in

set expandtab           " Expand tabs to spaces

set listchars=tab:▸\      " Use custom symbols to
set listchars+=trail:·    " represent invisible symbols
set listchars+=eol:↴
set listchars+=nbsp:_

set showmatch           " highlight matching [{()}]

set laststatus=2        " Always show statusline
set showtabline=2       " and tabline

set mouse+=a            " Enable mouse support

" Disable annoying error noises
set noerrorbells
set visualbell
set t_vb=

set splitbelow          " Open new vertical split bottom
set splitright          " Open new horizontal splits right

set linebreak           " Have lines wrap instead of continue off-screen

set scrolloff=12        " Keep cursor in approximately the middle of the screen

set updatetime=100      " Some plugins require fast updatetime

" I: Disable the default Vim startup message
" c: Don't give messages like "The only match", "Pattern not found", etc.
set shortmess+=Ic

" set ruler               " Show the cursor position
set nostartofline       " Don't set cursor to start of line when moving around

set title               " Show the filename in window titlebar

" set gdefault          " Add the g flag to search/replace by default (deprecated)

" Tab completion for files/buffers
set wildmenu                " Visual autocomplete for command menu
set wildmode=longest:full   " Complete longest common string : show the wildmenu
set wildmode+=full          " then start completing each full match

" Use the system clipboard as the default register
set clipboard=unnamed
if has('unnamedplus')
  set clipboard+=unnamedplus
endif

set encoding=utf-8
set autoread            " Reload files when changed on disk
set hidden              " Allows having hidden buffer (not displayed in any window)
set backspace=indent,eol,start    " Allow backspace in insert mode

" Format options
" 'r': Automatically insert the current comment leader after hitting <Enter> in
" Insert mode.
" 'j': When it makes sense, remove a comment leader when joining lines.
set formatoptions+=rj

" --INSERT-- is unncessary because of lightline
set noshowmode


" Cursor Shape                                             *vimrc_cursor_shape*
" -----------------------------------------------------------------------------
" https://vim.fandom.com/wiki/Change_cursor_shape_in_different_modes
" 0 -> Solid block
" 1 -> Solid vertical bar
" 2 -> Solid underscore
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"  " INSERT
  let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"  " REPLACE
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"  " NORMAL (ELSE)
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_SR = "\<Esc>]50;CursorShape=2\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif


" Searching                                             *vimrc_search_settings*
" -----------------------------------------------------------------------------
set incsearch           " search as characters are entered
set hlsearch            " highlight matches
set ignorecase          " Ignore case in searches by default
set smartcase           " But make it case sensitive if an uppercase is entered

" Turn off search highlight (this becomes useless with vim-cool plugin)
nnoremap <Leader>h :nohlsearch<cr>
vnoremap <Leader>h :nohlsearch<cr>


" Centralize backups, swapfiles and undo history
" -----------------------------------------------------------------------------
set backupdir=~/.vim/backups/
set directory=~/.vim/swaps/
set undofile
set undodir=~/.vim/undo/


" Lose bad habits
" -----------------------------------------------------------------------------
" Try to prevent bad habits like using the arrow keys for movement. This is
" not the only possible bad habit. For example, holding down the h/j/k/l keys
" for movement, rather than using more efficient movement commands, is also a
" bad habit. Don't want it in insert mode as it's necessary to navigate while
" writing

" Normal Mode
nnoremap <Left>  :echoe "Use h"<CR>
nnoremap <Right> :echoe "Use l"<CR>
nnoremap <Up>    :echoe "Use k"<CR>
nnoremap <Down>  :echoe "Use j"<CR>

" Visual Mode
vnoremap <Left>  :echoe "Use h"<CR>
vnoremap <Right> :echoe "Use l"<CR>
vnoremap <Up>    :echoe "Use k"<CR>
vnoremap <Down>  :echoe "Use j"<CR>


" =============================================================================
" FUNCTIONS                                                   *vimrc_functions*
" =============================================================================

" Set all the open windows to equal width.
" `wincmd =` changes the height as well, we will extract the height
" changes from `winrestcmd` and execute it.
" Use: NERDTree
function! SetWindowsToEqualWidth()
  let l:restoreCommands = split(winrestcmd(), '|')
  let l:heightCommands = filter(
        \ l:restoreCommands,
        \ { idx, cmd -> cmd =~# '^:\dresize' }
        \ )
  wincmd =
  execute join(l:heightCommands, '|')
endfunction


" Set to the given color scheme using all the commands listed in
" 'color_scheme_config', if it exists.
" Default: g:vimrc_colors_name
function! SetColorScheme(name = g:vimrc_colors_name) abort
  let g:vimrc_colors_name = a:name
  for l:item in g:color_scheme_config[a:name]
    execute l:item
  endfor
endfunction


" Set the lightline color scheme
function! SetLightlineColorScheme(name) abort
  let l:filepath = globpath(
        \ &runtimepath,
        \ join(['autoload/lightline/colorscheme/', a:name, '.vim'], ''), 0, 1)[0]
  execute join(['source', l:filepath], ' ')
  let g:lightline.colorscheme = a:name
  call lightline#init()
  call lightline#colorscheme()
  call lightline#update()
endfunction


" Update the tmuxline config according to the current theme and store it under
" the assets directory and also override the current tmux theme file.
function! SetTmuxColorScheme(name, lightline_color = "lightline") abort
  " Do not run the command on vim startup but only on subsequent calls to
  " SetColorScheme function.
  if exists('g:loaded_vimrc_colors')
    execute 'Tmuxline ' . a:lightline_color
    execute 'TmuxlineSnapshot! ~/dotfiles/tmux/tmuxline/assets/' . a:name . '.tmux.conf'
    TmuxlineSnapshot! ~/dotfiles/tmux/tmuxline/current.tmux.conf
    silent !tmux source-file ~/dotfiles/tmux/tmux.conf
  endif
endfunction


" =============================================================================
" MAPPINGS                                                     *vimrc_mappings*
" =============================================================================
" Ref: Get list of all custom mappings `:map [mapping]`

" Unbind some useless/annoying default key bindings.
" 'Q' in normal mode enters Ex mode. You almost never want this.
nmap Q <Nop>

" Quick save
noremap <leader>w :w<CR>
noremap <leader>q :q<CR>
" noremap <leader>wq :wq<CR>

" Move vertically by visual line
nnoremap j gj
nnoremap k gk

" Open new line below and above current line
" Both the map and the actual keys are of length 2 or 3
" nnoremap <leader>o o<esc>
" nnoremap <leader>O O<esc>

" Split with leader (same as that of tmux)
nnoremap <Leader>- :sp<CR>
nnoremap <Leader>\| :vsp<CR>

" Buffer management
nnoremap ]b :bnext<CR>
nnoremap [b :bprev<CR>
nnoremap <leader>bd :bdelete<CR>
nnoremap <leader><leader> <C-^>

" Movement in insert mode
inoremap <C-h> <C-o>h
inoremap <C-l> <C-o>a
inoremap <C-j> <C-o>j
inoremap <C-k> <C-o>k

" Capital JK move code lines/blocks up & down (only in visual mode)
xnoremap J :m '>+1<CR>gv=gv
xnoremap K :m '<-2<CR>gv=gv

" Visual indentation goes back to same selection
xnoremap < <gv
xnoremap > >gv

" Quicker window movement
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l

" <tab> / <s-tab> | Circular windows navigation
" nnoremap <tab>   <c-w>w
" nnoremap <S-tab> <c-w>W

" Keep the cursor at
" (t) &scrolloff lines away from the top
" (z) the center
nnoremap * *zz
nnoremap # #zz
nnoremap n nzz
nnoremap N Nzz
nnoremap <C-o> <C-o>zz
nnoremap <C-i> <C-i>zz

" Search and Replace the word on cursor globally
nnoremap <Leader>r :%s/\<<C-r><C-w>\>/

" Mapping for the custom function
nnoremap <leader>= :call SetWindowsToEqualWidth()<CR>

" Set the terminal height to 2.5 of the current window and
" open it in the directory of the file
nmap <leader>t
      \ :let $VIM_DIR=expand('%:p:h')<CR>
      \ :let &termwinsize = float2nr(winheight(0) / 2.5) . "x0"<CR>
      \ :terminal<CR>
      \ cd $VIM_DIR<CR>
      \ clear<CR>

nmap <leader>vt
      \ :let $VIM_DIR=expand('%:p:h')<CR>
      \ :let &termwinsize = ''<CR>
      \ :vert terminal<CR>
      \ cd $VIM_DIR<CR>
      \ clear<CR>

" Ref: https://vim.fandom.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
nmap <leader>hi
      \ :echo "hi<" . synIDattr(synID(line("."), col("."), 1), "name") . '> trans<'
      \ . synIDattr(synID(line("."), col("."), 0), "name") . "> lo<"
      \ . synIDattr(synIDtrans(synID(line("."), col("."), 1)), "name") . ">"<CR>


" =============================================================================
" COMMANDS                                                     *vimrc_commands*
" =============================================================================

" This always happens!
command! W :w
command! Q :q
command! Qa :qa
command! Wa :wa
command! Wqa :wqa
command! WQa :wqa



" =============================================================================
" AUTOCOMMANDS                                             *vimrc_autocommands*
" =============================================================================

" Automatic reloading of .vimrc on save
" Nested is necessary to correctly reload lightline/airline
" augroup auto_reload_vimrc
"   autocmd!
"   autocmd BufWritePost .vimrc,vimrc nested source $MYVIMRC
" augroup END

" Highlight current line, but only in active window
" augroup cursor_line_only_in_active_window
"   autocmd!
"   autocmd VimEnter,WinEnter,BufWinEnter * setl cursorline
"   autocmd WinLeave * setl nocursorline
" augroup END

" Help filetype detection
augroup filetype_detection
  autocmd!
  autocmd BufRead,BufNewFile Vagrantfile,Brewfile setl ft=ruby
  autocmd BufRead,BufNewFile *.tmux.conf setl ft=tmux
augroup END

" Various indent guide for filetypes
" ts = tabstop
" sw = shiftwidth
" sts = softtabstop
" et = expandtab (Globally set)
" net = noexpandtab
augroup filetype_autocommands
  autocmd!
  " autocmd FileType help nnoremap <buffer> q :q <CR>
  autocmd FileType json,racket,sh,vim setl ts=2 sw=2
  autocmd FileType gitconfig,python,sml setl ts=4 sw=4
  " vim-racket plugin sets it to ';', remove it and set it to ';;'
  autocmd FileType racket setl comments-=:; comments+=:;;
  autocmd FileType python setl colorcolumn=88
augroup END

" Resize windows to equal width when vim resizes (&columns &lines changed)
" augroup equal_window_width_on_vim_resize
"   autocmd!
"   autocmd VimResized * call SetWindowsToEqualWidth()
" augroup END

" Triger `autoread` when files changes on disk and notify after file change
" https://unix.stackexchange.com/a/383044
augroup auto_reload_file_when_changed
  autocmd!
  autocmd FocusGained,BufEnter,CursorHold,CursorHoldI *
    \ if mode() !~ '\v(c|r.?|!|t)' && getcmdwintype() == ''
    \ | checktime
    \ | endif
  autocmd FileChangedShellPost *
    \ echohl WarningMsg
    \ | echo "File changed on disk. Buffer reloaded."
    \ | echohl None
augroup END


" =============================================================================
" PLUGIN CONFIG                                           *vimrc_plugin_config*
" =============================================================================

" ALE                                                        *vimrc_ale_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/dense-analysis/ale

let g:ale_enabled = 1
let g:ale_sign_column_always = 1

" Using coc.nvim for lsp
let g:ale_disable_lsp = 1

" Error message format
let g:ale_echo_msg_info_str = 'I'
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %code: %%s [%severity%]'

" Lint only when I save the file
let g:ale_lint_on_enter = 0
let g:ale_lint_on_save = 1
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_insert_leave = 1

" Linters
let g:ale_linters_explicit = 1
let g:ale_linters = {
      \ 'python': ['flake8', 'mypy'],
      \ 'racket': ['raco'],
      \ 'sh': ['shellcheck'],
      \ 'sml': ['smlnj'],
      \ 'yaml': ['yamllint'],
      \ }

" Set this variable to 1 to fix files when you save them.
let g:ale_fix_on_save = 1

" Formatters
let g:ale_fixers = {
      \ '*': ['remove_trailing_lines', 'trim_whitespace'],
      \ 'python': ['black', 'isort'],
      \ }

" Custom symbols
let g:ale_sign_error = '✘'
let g:ale_sign_warning = ''
let g:ale_sign_info = 'ℹ'

" Remove background color
highlight clear ALEErrorSign
highlight clear ALEWarningSign

" Navigate between errors
nmap <silent> [a <Plug>(ale_previous_wrap)
nmap <silent> ]a <Plug>(ale_next_wrap)


" Coc                                                        *vimrc_coc_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/neoclide/coc.nvim

function! s:coc_setup()
  if !exists(':CocStart') || exists('g:did_coc_loaded')
    return
  endif

  CocStart

  let g:coc_global_extensions = [
        \ 'coc-json',
        \ 'coc-sh',
        \ 'coc-vimlsp',
        \ 'coc-pyright',
        \ ]

  let g:coc_status_warning_sign = ''
  let g:coc_status_error_sign = '✘'

  " Trigger key for going to the next snippet position (default)
  let g:coc_snippet_next = '<c-j>'
  let g:coc_snippet_prev = '<c-k>'

  " Use tab for trigger completion with characters ahead and navigate.
  " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
  " other plugin before putting this into your config.
  inoremap <silent><expr> <TAB>
        \ pumvisible() ? "\<C-n>" :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ coc#refresh()
  inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

  function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~# '\s'
  endfunction

  " Use <c-space> to trigger completion.
  inoremap <silent><expr> <c-space> coc#refresh()

  " Make <CR> auto-select the first completion item and notify coc.nvim to
  " format on enter, <cr> could be remapped by other vim plugin
  inoremap <silent><expr> <cr>
        \ pumvisible()
        \ ? coc#_select_confirm()
        \ : "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

  " Use `[c` and `]c` to navigate diagnostics
  " Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
  nmap <silent> [c <Plug>(coc-diagnostic-prev)
  nmap <silent> ]c <Plug>(coc-diagnostic-next)

  " GoTo code navigation.
  nmap <silent> gd <Plug>(coc-definition)
  nmap <silent> gy <Plug>(coc-type-definition)
  nmap <silent> gi <Plug>(coc-implementation)
  nmap <silent> gr <Plug>(coc-references)

  " Use K to show documentation in preview window.
  nnoremap <silent> K :call <SID>show_documentation()<CR>

  function! s:show_documentation()
    if (index(['vim','help'], &filetype) >= 0)
      execute 'h '.expand('<cword>')
    elseif (coc#rpc#ready())
      call CocActionAsync('doHover')
    else
      execute '!' . &keywordprg . " " . expand('<cword>')
    endif
  endfunction

  " Highlight the symbol and its references when holding the cursor.
  autocmd CursorHold * silent call CocActionAsync('highlight')

  " Symbol renaming.
  nmap <leader>rn <Plug>(coc-rename)

  augroup coc_autocmds
    autocmd!
    " Update signature help on jump placeholder.
    autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
  augroup end

  " Map function and class text objects
  " NOTE: Requires 'textDocument.documentSymbol' support from the language server.
  xmap if <Plug>(coc-funcobj-i)
  omap if <Plug>(coc-funcobj-i)
  xmap af <Plug>(coc-funcobj-a)
  omap af <Plug>(coc-funcobj-a)
  xmap ic <Plug>(coc-classobj-i)
  omap ic <Plug>(coc-classobj-i)
  xmap ac <Plug>(coc-classobj-a)
  omap ac <Plug>(coc-classobj-a)

  " Remap <C-f> and <C-b> for scroll float windows/popups.
  " if has('nvim-0.4.0') || has('patch-8.2.0750')
  "   nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  "   nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  "   inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
  "   inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
  "   vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  "   vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  " endif

  " Use CTRL-S for selections ranges.
  " Requires 'textDocument/selectionRange' support of language server.
  nmap <silent> <C-s> <Plug>(coc-range-select)
  xmap <silent> <C-s> <Plug>(coc-range-select)
endfunction


" Coc control                                               *vimrc_coc_control*
" -----------------------------------------------------------------------------
command! -nargs=0 -complete=command CocSetup :call <SID>coc_setup()

if !g:coc_startup_manual_only
  " Only start for specific filetype
  augroup coc_control
    autocmd!
    autocmd FileType json,python,sh,vim CocSetup
  augroup END

  " Use autocmd to force lightline update.
  augroup coc_lightline_update
    autocmd!
    autocmd User CocStatusChange call lightline#update()
    autocmd User CocDiagnosticChange call lightline#update()
  augroup END

  if !g:keep_coc_in_control
    CocSetup
  endif
endif


" Color scheme                                      *vimrc_color_scheme_config*
" -----------------------------------------------------------------------------
" Ref:
"   vim-monokai-tasty: https://github.com/patstockwell/vim-monokai-tasty
"   sonokai: https://github.com/sainnhe/sonokai
"   gruvbox-material: https://github.com/sainnhe/gruvbox-material

" Color scheme configuration list
let g:color_scheme_config = {}

let g:color_scheme_config['vim-monokai-tasty'] = [
      \ 'let g:vim_monokai_tasty_italic = 0',
      \ 'colorscheme vim-monokai-tasty',
      \ 'call SetLightlineColorScheme("custom_monokai_tasty")',
      \ 'call SetTmuxColorScheme("monokai-tasty")',
      \ ]

" Sonokai Style: 'default', 'atlantis', 'andromeda', 'shusia', 'maia'
let g:color_scheme_config['sonokai'] = [
      \ "let g:sonokai_style = 'shusia'",
      \ 'let g:sonokai_enable_italic = 1',
      \ 'let g:sonokai_disable_italic_comment =  1',
      \ 'let g:sonokai_better_performance = 1',
      \ "let g:sonokai_sign_column_background = 'none'",
      \ 'colorscheme sonokai',
      \ 'call SetLightlineColorScheme("sonokai")',
      \ 'call SetTmuxColorScheme("sonokai-shusia", "lightline_insert")',
      \ ]

" Palette: 'original', 'mix', 'material'
" Background: 'hard', 'medium', 'soft'
let g:color_scheme_config['gruvbox-material'] = [
    \ "let g:gruvbox_material_palette = 'original'",
    \ "let g:gruvbox_material_background = 'medium'",
    \ 'let g:gruvbox_material_enable_italic = 1',
    \ 'let g:gruvbox_material_disable_italic_comment = 1',
    \ "let g:gruvbox_material_sign_column_background = 'none'",
    \ 'let g:gruvbox_material_better_performance = 1',
    \ 'colorscheme gruvbox-material',
    \ 'call SetLightlineColorScheme("gruvbox_material")',
    \ 'call SetTmuxColorScheme("gruvbox-material")',
    \ ]


" Fugitive                                              *vimrc_fugitive_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/tpope/vim-fugitive

nnoremap <leader>gs :G<CR>
nnoremap <leader>gp :Gpush<CR>


" Incsearch                                            *vimrc_incsearch_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/haya14busa/incsearch.vim

map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)


" Indentline                                          *vimrc_indentline_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/Yggdroot/indentLine

let g:indentLine_char = '¦' " | ¦ ┆ │ ┊

let g:indentLine_showFirstIndentLevel = 0
" let g:indentLine_concealcursor = ""

let g:indentLine_fileTypeExclude = [
      \ 'startify',
      \ 'help',
      \ 'nerdtree',
      \ ]

" Use colors from the colorscheme
if g:vimrc_colors_name ==# 'vim-monokai-tasty'
  let g:indentLine_setColors = 1
else
  let g:indentLine_setColors = 0
endif

" Show quotes in JSON file
augroup json_conceal_level
  autocmd!
  autocmd BufEnter,BufWinEnter *.json let g:indentLine_setConceal = 0
  autocmd BufLeave,BufWinLeave *.json let g:indentLine_setConceal = 1
augroup END


" Lightline                                            *vimrc_lightline_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/itchyny/lightline.vim
" NOTE:
" - Lightline configuration should come before color scheme configuration
" - Lightline colorscheme is set using color_scheme_config

let g:lightline = {}

let g:lightline.active = {
      \ 'left': [
      \   ['mode', 'paste'],
      \   ['git_status'],
      \   ['filepath']
      \ ],
      \ 'right': [
      \   ['linter_errors', 'linter_warnings', 'linter_infos', 'lineinfo'],
      \   ['filetype', 'fileformat'],
      \   ['coc_status'],
      \ ]
      \ }

let g:lightline.inactive = {
      \ 'left': [ ['absolutepath'] ],
      \ 'right': [ ['lineinfo'] ]
      \ }

let g:lightline.tabline = {
      \ 'left': [['vim_logo', 'tabs']],
      \ }

let g:lightline.component = {
      \ 'vim_logo': "\ue7c5",
      \ 'lineinfo': '%2p%%  %2l:%-2c%<',
      \ 'filepath': "%t%{&modified ? ' [+]' : ''}%{&readonly ? ' [RO]' : ''}",
      \ 'filetype': "%{winwidth(0) > 70 ? (&ft !=# '' ? &ft : 'no ft') : ''}",
      \ 'fileformat': "%{winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) . '['.&ff.']' : ''}",
      \ 'git_status': "%{LightlineGitStatus()}",
      \ 'coc_status': "%{get(g:, 'coc_status', '')}",
      \ }

let g:lightline.component_expand = {
      \ 'linter_infos': 'lightline#ale#infos',
      \ 'linter_warnings': 'lightline#ale#warnings',
      \ 'linter_errors': 'lightline#ale#errors',
      \ }

let g:lightline.component_type = {
      \ 'linter_infos': 'right',
      \ 'linter_warnings': 'warning',
      \ 'linter_errors': 'error',
      \ }

" Ale error indicator for lightline
let g:lightline#ale#indicator_infos = "i"
let g:lightline#ale#indicator_warnings = "!"
let g:lightline#ale#indicator_errors = "✘"

function! LightlineGitStatus()
  if exists('g:loaded_fugitive')
    let l:branch = FugitiveHead()
    if l:branch !=# ''
      return ' ' . l:branch
    endif
    return ''
  endif
endfunction


" NERDCommenter                                    *vimrc_nerdcommenter_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/preservim/nerdcommenter

" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1

" Allow commenting and inverting empty lines
let g:NERDCommentEmptyLines = 1

" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1

" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1

" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'

" Custom delimiters for filetype
let g:NERDCustomDelimiters = {
      \ 'racket': { 'left': ';;', 'nested': 1, 'leftAlt': '#|', 'rightAlt': '|#', 'nestedAlt': 1 }
      \ }


" NERDTree                                              *vimrc_nerdtree_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/preservim/nerdtree

" Close NERDTree on opening the file
let g:NERDTreeQuitOnOpen = 1

" Automatically delete the buffer of the file you just deleted with NerdTree
let g:NERDTreeAutoDeleteBuffer = 1

" Disables display of 'Bookmarks' label and 'Press ? for help' text.
let g:NERDTreeMinimalUI = 1

" Use a smaller, more compact menu (on a single line)
let g:NERDTreeMinimalMenu = 1

" Show hidden files
let g:NERDTreeShowHidden = 1

" Ignore files in NERDTree
let g:NERDTreeIgnore = [
      \ '\.git$',
      \ '\.DS_Store',
      \ '\.pyc$',
      \ '\.pyo$',
      \ '__pycache__$',
      \ '\.mypy_cache$',
      \ ]

" 1. Close vim if only window left is NERDTree
" 2. Load NERDTree and startify if vim is ran without arguments
" 3. Disable signcolumn in NERDTree
augroup nerdtree
  autocmd!
  autocmd BufEnter *
        \ if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree())
        \ | q
        \ | endif
  " autocmd VimEnter *
  "       \ if !argc()
  "       \ | Startify
  "       \ | NERDTree
  "       \ | wincmd w
  "       \ | endif
  autocmd FileType nerdtree setlocal signcolumn=no
augroup END

" NOTE: Make all windows the same width whenever a NERDTree is opened or closed
" but do not change the height. This is done using `SetWindowsToEqualWidth()`.

" Set key to Ctrl-n to open nerd tree.
nnoremap <C-n> :NERDTreeToggle<CR>
nnoremap <C-f> :NERDTreeFind<CR>


" Python syntax                                    *vimrc_python_syntax_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/vim-python/python-syntax

" Enable all syntax highlighting features
let g:python_highlight_all = 1


" Startify                                              *vimrc_startify_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/mhinz/vim-startify

nnoremap <space>` :Startify<CR>

augroup start_startify_on_vim_startup
  autocmd!
  autocmd VimEnter * if !argc() | Startify | endif
augroup END

" Startify header
let g:ascii_vim = [
      \ '',
      \ '              ██╗   ██╗██╗███╗   ███╗',
      \ '              ██║   ██║██║████╗ ████║',
      \ '              ██║   ██║██║██╔████╔██║',
      \ '              ╚██╗ ██╔╝██║██║╚██╔╝██║',
      \ '               ╚████╔╝ ██║██║ ╚═╝ ██║',
      \ '                ╚═══╝  ╚═╝╚═╝     ╚═╝',
      \ ''
      \ ]

let g:startify_custom_header =
      \ 'startify#pad(g:ascii_vim + startify#fortune#boxed())'

let g:startify_lists = [
      \ {'type': 'dir',       'header': ['   Current Directory '. getcwd()]},
      \ {'type': 'files',     'header': ['   Files']},
      \ {'type': 'sessions',  'header': ['   Sessions']},
      \ {'type': 'bookmarks', 'header': ['   Bookmarks']},
      \ ]

let g:startify_bookmarks = [
      \ {'v': '~/dotfiles/vim/vimrc'},
      \ {'b': '~/dotfiles/bash/bashrc'},
      \ {'s': '~/dotfiles/bootstrap'},
      \ {'t': '~/dotfiles/tmux/tmux.conf'}
      \ ]

" Automatically update sessions before leaving Vim and before loading a new
" session via :SLoad
let g:startify_session_persistence = 1

let g:startify_session_delete_buffers = 1

" When opening a file or bookmark, seek and change to the git root directory
" if any and not to the file directory.
let g:startify_change_to_dir = 0
let g:startify_change_to_vcs_root = 1

" Close NERDTree tabs before saving a session and get the buffer back to the
" original tabpage.
let g:startify_session_before_save = [
      \ 'let $CURRENT_TABPAGE = tabpagenr()',
      \ 'tabdo NERDTreeClose',
      \ 'execute $CURRENT_TABPAGE . "tabnext"',
      \ ]


" Tmuxline                                              *vimrc_tmuxline_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/edkolev/tmuxline.vim

let g:tmuxline_status_justify = 'left'
let g:tmuxline_powerline_separators = 0

let g:tmuxline_preset = {
      \ 'a'    : '#S',
      \ 'win'  : [ '#I: #W #F' ],
      \ 'cwin' : [ '#I: #W #F' ],
      \ 'x'    : '#(~/dotfiles/tmux/scripts/music.sh) '
      \          . '#{?client_prefix,#[fg=black]#[bg=yellow] PREFIX,'
      \          . '#{?rectangle_toggle,#[fg=black]#[bg=blue] C-BLOCK,'
      \          . '#{?pane_in_mode,#[fg=black]#[bg=blue] COPY,'
      \          . '#{?window_zoomed_flag,#[fg=black]#[bg=green] ZOOMED,}}}}',
      \ 'y'    : [ '%a %d %b', '%H:%M', '#(~/dotfiles/tmux/scripts/battery.sh)' ],
      \ 'z'    : '#H'
      \ }


" Vim-cool                                              *vimrc_vim_cool_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/romainl/vim-cool

" Show number of matches in the command-line (match 12 of 20)
let g:CoolTotalMatches = 1


" Vim-external                                      *vimrc_vim_external_config*
" -----------------------------------------------------------------------------
" Ref: https://github.com/itchyny/vim-external

" map <Leader>e <Plug>(external-editor)
" map <Leader>n <Plug>(external-explorer)
map <Leader>b <Plug>(external-browser)


" Set the color scheme                                 *vimrc_set_color_scheme*
" -----------------------------------------------------------------------------
" NOTE: This should come at the end of the file
"
" It goes like this:
" Vim startup: Load vim and lightline colorscheme (tmux sourced .tmux.conf)
" Reload vimrc: If the colorscheme is suppose to be changed, call the function
"               to update the colorscheme for vim, lightline and tmuxline.

try
  if !exists('g:colors_name') || g:colors_name !=# g:vimrc_colors_name
    call SetColorScheme()
    let g:loaded_vimrc_colors = 1
  endif
catch /.*/
  colorscheme desert
  set nocursorline
  set notermguicolors
endtry

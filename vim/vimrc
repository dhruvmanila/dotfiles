" Comments in Vimscript start with a `"`.

" VI compatible mode is disabled so that VIm things work
set nocompatible

" Set leader key
let mapleader=" "       " leader is space


" =============================================================================
"   PLUGINS
" =============================================================================
call plug#begin('~/.vim/plugged')

" Colorschemes
Plug 'patstockwell/vim-monokai-tasty'

" Search
Plug 'romainl/vim-cool'
Plug 'haya14busa/incsearch.vim'

" Syntactic language support
Plug 'vim-python/python-syntax'
Plug 'dense-analysis/ale'
Plug 'stephpy/vim-yaml'
Plug 'wlangstroth/vim-racket'

" Text manipulations
Plug 'preservim/nerdcommenter'
" Plug 'tpope/vim-surround'

" GUI enhancements
Plug 'itchyny/lightline.vim'
Plug 'maximbaz/lightline-ale'
Plug 'mhinz/vim-startify'
Plug 'preservim/nerdtree'
Plug 'Yggdroot/indentLine'

" Git plugin
Plug 'tpope/vim-fugitive'

" Tmux GUI
" For now using the autocmd group auto_reload_file_when_changed
" Plug 'tmux-plugins/vim-tmux-focus-events'

call plug#end()


" =============================================================================
"  EDITOR SETTINGS
" =============================================================================

" Colorscheme
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Turn on syntax highlighting.
syntax on

if exists('+termguicolors')
  set termguicolors
  " The commands below are needed for tmux + termguicolors
  " This is only necessary if you use "set termguicolors".
  let &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
  let &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
  let g:vim_monokai_tasty_italic = 1
  silent! colorscheme vim-monokai-tasty
else
  silent! colorscheme desert
  set nocursorline
endif


" If you don't know what the name of a particular hightlight is, you can use `What`.
" It will print out the syntax group that the cursor is currently above.
" Ref: https://www.reddit.com/r/vim/comments/6z4aau/how_to_stop_vim_from_autohighlighting_italics_in/
command! What echo synIDattr(synID(line('.'), col('.'), 1), 'name')

" Turn on loading of plugin files, indent files and filetype detection
if has('autocmd')
  filetype plugin indent on
endif

" Vim can autodetect this based on $TERM (e.g. 'xterm-256color')
" but it can be set to force 256 colors.
" if !has('gui_running')
"   set t_Co=256
" endif


" General Config
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set lazyredraw

set number              " show line numbers
set relativenumber      " show relative numbering

if has('cmdline_info')
  set showcmd             " Show the command being typed in
endif                     " the right side of the bottom bar.

" Global <TAB> settings
" set expandtab
" set tabstop=4
" set shiftwidth=4
" set softtabstop=4

" Use custom symbols to represent invisible characters
set listchars=tab:▸\
set listchars+=trail:·
set listchars+=eol:↴
set listchars+=nbsp:_

set showmatch           " highlight matching [{()}]

" Always show the status line at the bottom
set laststatus=2
set showtabline=2

set mouse+=a            " Enable mouse support

" Disable annoying error noises
set noerrorbells
set visualbell
set t_vb=

set splitbelow          " Open new vertical split bottom
set splitright          " Open new horizontal splits right

set linebreak           " Have lines wrap instead of continue off-screen

set scrolloff=12        " Keep cursor in approximately the middle of the screen

set updatetime=100      " Some plugins require fast updatetime

set ttyfast             " Improve redrawing

" Disable the default Vim startup message
" ':help shortmess' to look at other flags
set shortmess+=I

set ruler               " Show the cursor position
set nostartofline       " Don't set cursor to start of line when moving around

set title               " Show the filename in window titlebar

" set gdefault          " Add the g flag to search/replace by default (deprecated)

" Tab completion for files/buffers
set wildmenu             " Visual autocomplete for command menu
set wildmode=longest     " Complete longest common string
set wildmode+=list       " then list alternatives
set wildmode+=full       " then complete each full match showing the wildmenu

" Use the system clipboard as the default register
set clipboard=unnamed
if has('unnamedplus')
  set clipboard+=unnamedplus
endif

set encoding=utf-8

" Reload files when changed on disk
set autoread

" Cursor shape for tmux running in iTerm2
" Cursor settings:
" NOTE: This seems to be incorrect
"  1 -> blinking block
"  2 -> solid block
"  3 -> blinking underscore
"  4 -> solid underscore
"  5 -> blinking vertical bar
"  6 -> solid vertical bar
" https://vim.fandom.com/wiki/Change_cursor_shape_in_different_modes
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"  " INSERT
  let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"  " REPLACE
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"  " NORMAL (ELSE)
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_SR = "\<Esc>]50;CursorShape=2\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

set hidden              " Allows having hidden buffer (not displayed in any window)

" Allow backspace in insert mode
set backspace=indent,eol,start

" Format options
" 'r': Automatically insert the current comment leader after hitting <Enter> in
" Insert mode.
" 'j': When it makes sense, remove a comment leader when joining lines.
set formatoptions+=rj

" --INSERT-- is unncessary because of lightline
set noshowmode


" Searching
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set incsearch           " search as characters are entered
set hlsearch            " highlight matches
set ignorecase          " Ignore case in searches by default
set smartcase           " But make it case sensitive if an uppercase is entered

" Turn off search highlight (this becomes useless with vim-cool plugin)
nnoremap <Leader>h :nohlsearch<cr>
vnoremap <Leader>h :nohlsearch<cr>


" Centralize backups, swapfiles and undo history
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set backupdir=~/.vim/backups/
set directory=~/.vim/swaps/
set undofile
set undodir=~/.vim/undo/


" Lose bad habits
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Try to prevent bad habits like using the arrow keys for movement. This is
" not the only possible bad habit. For example, holding down the h/j/k/l keys
" for movement, rather than using more efficient movement commands, is also a
" bad habit. Don't want it in insert mode as it's necessary to navigate while
" writing

" Normal Mode
nnoremap <Left>  :echoe "Use h"<CR>
nnoremap <Right> :echoe "Use l"<CR>
nnoremap <Up>    :echoe "Use k"<CR>
nnoremap <Down>  :echoe "Use j"<CR>

" Visual Mode
vnoremap <Left>  :echoe "Use h"<CR>
vnoremap <Right> :echoe "Use l"<CR>
vnoremap <Up>    :echoe "Use k"<CR>
vnoremap <Down>  :echoe "Use j"<CR>


" Custom functions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Set all the open windows to equal width.
" `wincmd =` changes the height as well, we will extract the height
" changes from `winrestcmd` and execute it.
" Used when toggling NERDTree on and off
function! SetWindowsToEqualWidth()
  let restoreCommands = split(winrestcmd(), '|')
  " `=~#` Regexp matches with match case
  let heightCommands = filter(
        \ restoreCommands,
        \ { idx, cmd -> cmd =~# '^:\dresize' }
        \ )
  wincmd =
  execute join(heightCommands, '|')
endfunction


" Custom mappings
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Ref: Get list of all custom mappings `:map`

" Unbind some useless/annoying default key bindings.
" 'Q' in normal mode enters Ex mode. You almost never want this.
nmap Q <Nop>

" Quicker window movement
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l

" Mapping for the custom function
nnoremap <leader>= :call SetWindowsToEqualWidth()<CR>

" Set the terminal height to 2.5 of the current window and
" open it in the directory of the file
map <leader>t
      \ :let $VIM_DIR=expand('%:p:h')<CR>
      \ :let &termwinsize = float2nr(winheight(0) / 2.5) . "x0"<CR>
      \ :terminal<CR>
      \ cd $VIM_DIR<CR>
      \ clear<CR>

map <leader>vt
      \ :let $VIM_DIR=expand('%:p:h')<CR>
      \ :let &termwinsize = ''<CR>
      \ :vert terminal<CR>
      \ cd $VIM_DIR<CR>
      \ clear<CR>


" Auto commands
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Automatic reloading of .vimrc on save
" Nested is necessary to correctly reload lightline/airline
augroup auto_reload_vimrc
  autocmd!
  autocmd BufWritePost .vimrc,vimrc nested source $MYVIMRC
augroup END

" Highlight current line, but only in active window
augroup cursor_line_only_in_active_window
  autocmd!
  autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline
  autocmd WinLeave * setlocal nocursorline
augroup END

" Help filetype detection
augroup filetype_detection
  autocmd!
  autocmd BufRead,BufNewFile Vagrantfile,Brewfile set filetype=ruby
augroup END

" Resize windows to equal width when vim resizes (&columns &lines changed)
augroup equal_window_width_on_vim_resize
  autocmd!
  autocmd VimResized * call SetWindowsToEqualWidth()
augroup END

" Triger `autoread` when files changes on disk and notify after file change
" https://unix.stackexchange.com/a/383044
augroup auto_reload_file_when_changed
  autocmd!
  autocmd FocusGained,BufEnter,CursorHold,CursorHoldI *
    \ if mode() !~ '\v(c|r.?|!|t)' && getcmdwintype() == ''
    \ | checktime
    \ | endif
  autocmd FileChangedShellPost *
    \ echohl WarningMsg
    \ | echo "File changed on disk. Buffer reloaded."
    \ | echohl None
augroup END


" =============================================================================
"   PLUGIN CONFIG
" =============================================================================

" Startify
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Disable startify header
let g:startify_custom_header = []

let g:startify_lists = [
      \ {'type': 'files',     'header': ['   Files']},
      \ {'type': 'dir',       'header': ['   Current Directory '. getcwd()]},
      \ {'type': 'sessions',  'header': ['   Sessions']},
      \ {'type': 'bookmarks', 'header': ['   Bookmarks']},
      \ ]

let g:startify_bookmarks = [
      \ {'v': '~/dotfiles/vim/vimrc'},
      \ {'b': '~/dotfiles/bash/bashrc'},
      \ ]

" Automatically update sessions before leaving Vim and before loading a new
" session via :SLoad
let g:startify_session_persistence = 1

let g:startify_session_delete_buffers = 0

" When opening a file or bookmark, seek and change to the git root directory
" if any and not to the file directory.
let g:startify_change_to_dir = 0
let g:startify_change_to_vcs_root = 1

" Close NERDTree tabs before saving a session and get the buffer back to the
" original tabpage.
let g:startify_session_before_save = [
      \ 'let $CURRENT_TABPAGE = tabpagenr()',
      \ 'tabdo NERDTreeClose',
      \ 'execute $CURRENT_TABPAGE . "tabnext"',
      \ ]


" ALE
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:ale_enabled = 1

" Error message format
let g:ale_echo_msg_info_str = 'I'
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %code: %%s [%severity%]'

" Don't lint on opening the files but when I save them
" Also, not when I do some edits
let g:ale_lint_on_enter = 0
let g:ale_lint_on_save = 1
let g:ale_lint_on_text_changed = 0
let g:ale_lint_on_insert_leave = 0

" Set this variable to 1 to fix files when you save them.
let g:ale_fix_on_save = 1
let g:ale_fixers = {'*': ['remove_trailing_lines', 'trim_whitespace']}

" Custom symbols
let g:ale_sign_error = '✘'
let g:ale_sign_warning = '!'
let g:ale_sign_info = 'i'

" Remove background color
highlight clear ALEErrorSign
highlight clear ALEWarningSign

" Navigate between errors
nmap <silent> [a <Plug>(ale_previous_wrap)
nmap <silent> ]a <Plug>(ale_next_wrap)


" Lightline
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:lightline = {
      \ 'colorscheme': 'custom_monokai_tasty',
      \ 'active': {
      \   'left': [
      \     ['mode', 'paste'],
      \     ['gitbranch', 'readonly'],
      \     ['filename']
      \   ],
      \   'right': [
      \     ['linter_errors', 'linter_warnings', 'linter_infos', 'lineinfo'],
      \     ['filetype'],
      \     ['fileformat', 'fileencoding'],
      \   ]
      \ },
      \ 'inactive': {
      \   'right': [
      \     ['lineinfo']
      \   ]
      \ },
      \ 'component': {
      \   'lineinfo': '%3p%%  %3l:%-2c%<',
      \ },
      \ 'component_function': {
      \   'gitbranch': 'LightlineGitBranch',
      \   'filename': 'LightlineFilename',
      \   'readonly': 'LightlineReadonly',
      \   'fileencoding': 'LightlineFileencoding',
      \   'filetype': 'LightlineFiletype',
      \   'fileformat': 'LightlineFileformat'
      \ },
      \ 'component_expand': {
      \   'linter_infos': 'lightline#ale#infos',
      \   'linter_warnings': 'lightline#ale#warnings',
      \   'linter_errors': 'lightline#ale#errors',
      \ },
      \ 'component_type': {
      \   'linter_infos': 'right',
      \   'linter_warnings': 'warning',
      \   'linter_errors': 'error',
      \ },
      \ 'separator': { 'left': "\ue0b0", 'right': "\ue0b2" },
      \ 'subseparator': { 'left': "\ue0b1", 'right': "\ue0b3" },
      \ }

" Ale error indicator for lightline
let g:lightline#ale#indicator_infos = "i"
let g:lightline#ale#indicator_warnings = "!"
let g:lightline#ale#indicator_errors = "✘"

" For vim-fugitive plugin: let branch = FugitiveHead()
" For vim-gitbranch plugin: let branch = gitbranch#name()
function! LightlineGitBranch()
  let branch = FugitiveHead()
  return branch !=# '' ? ' '.branch : ''
endfunction

" Extra: Filename from the project root (git repository)
" https://github.com/itchyny/lightline.vim/issues/293
function! LightlineFilename()
  let filename = expand('%:t') !=# '' ? expand('%:t') : '[No Name]'
  let modified = &modified ? ' +' : ''
  return filename . modified
endfunction

function! LightlineReadonly()
  return &readonly ? '' : ''
endfunction

function! LightlineFiletype()
  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
endfunction

function! LightlineFileencoding()
  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightlineFileformat()
  return winwidth(0) > 70 ? (&fileformat !=# '' ? &fileformat : '') : ''
endfunction


" NERDTree
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Automatically delete the buffer of the file you just deleted with NerdTree
let NERDTreeAutoDeleteBuffer = 1

" Disables display of 'Bookmarks' label and 'Press ? for help' text.
let NERDTreeMinimalUI = 1

" Show hidden files
let NERDTreeShowHidden = 1

" Ignore files in NERDTree
let NERDTreeIgnore = [
      \ '\.git$',
      \ '\.DS_Store',
      \ '\.pyc$',
      \ '\.pyo$',
      \ '__pycache__$',
      \ '\.mypy_cache$',
      \ ]

" 1. Close vim if only window left is NERDTree
" 2. Load NERDTree and startify if vim is ran without arguments
augroup nerdtree
  autocmd!
  autocmd BufEnter *
        \ if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree())
        \ | q
        \ | endif
  autocmd VimEnter *
        \ if !argc()
        \ | Startify
        \ | NERDTree
        \ | wincmd w
        \ | endif
augroup END

" NOTE: Make all windows the same width whenever a NERDTree is opened or closed
" but do not change the height. This is done using `SetWindowsToEqualWidth()`.
" Set key to Ctrl-n to open nerd tree.
nnoremap <C-n> :NERDTreeToggle<CR> :call SetWindowsToEqualWidth()<CR>
nnoremap <C-f> :NERDTreeFind<CR> :call SetWindowsToEqualWidth()<CR>
" Change focus to the NERDTree window if present, else open it.
" This will help in opening a file in a specific buffer, otherwise it opens
" the file in the first buffer from the NERDTree window.
nnoremap <leader>n :NERDTreeFocus<CR> :call SetWindowsToEqualWidth()<CR>


" NERDCommenter
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1
" Allow commenting and inverting empty lines
let g:NERDCommentEmptyLines = 1
" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1
" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1
" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'
" Custom delimiters for filetype
let g:NERDCustomDelimiters = {
  \ 'racket': { 'left': ';;' , 'leftAlt': ';' }
  \ }

" incsearch
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)


" Indent line
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:indentLine_char = '|'


" Vim cool
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Show number of matches in the command-line (match 12 of 20)
let g:CoolTotalMatches = 1

# NOTES: {{{
#
# `autoload`:
# - `-U`: It is recommended to pass this flag for the use of functions
#         supplied with the zsh distribution. This will suppress the usual
#         alias expansion during reading.
# - `-z`: Mark the function to be autoloaded using zsh style.
#
# `zle -N widget [function]`:
#   Create a new user-defined widget. When the new widget is invoked, the
#   specified function is called. If no function is specified, it defaults
#   to the same name as the widget. For more info: `man zshzle(1)` /WIDGETS
# }}}
# Respect these principles for ordering the sections:{{{
#
# `Plugins` should be near the beginning because we need to be able to override
# whatever interface they install.
#
# `Abbreviations` should be right after `Key Bindings` because it installs key
# bindings.
#
# `Syntax Highlighting` should be at the end, because the documentation of the
# plugin explains that it must be sourced after all custom widgets have been
# created (i.e., after all `zle -N` calls).
# }}}

# Use emacs keybindings, set to -v for vi bindings.
# Warning: {{{
#
# Don't move this line after the `Sourcing` section.
# It would reset `fzf` key bindings.
# }}}
bindkey -e

# By default, `run-help` is merely an alias for `man`.
# We want the `run-help` shell function which tries to figure out where to get
# the best help, and get it.
unalias run-help > /dev/null 2>&1
#                ├──────────────┘
#                └ to avoid error messages when we reload zshrc
#
# This should be in:
#     /usr/local/share/zsh/functions/
autoload -Uz run-help

# Completion {{{1

# This module offers enhancements to the completion menu:
# - Highlight matches.
# - Scroll through long lists.
# - Alternative style of selecting matches, called menu selection.
#
# This should be loaded *before* initializing completion (`compinit`).
# zmodload zsh/complist

# They install programmable completion functions for the most common Unix
# commands. They also enable some more central functionality, on which
# `zstyle`, for example, rely.
autoload -Uz compinit
compinit

# Options {{{1
#
# Set/unset each option using the `setopt` and `unsetopt` command. We can use
# `setopt NO<name>` to unset an option but we cannot find `NO<name>` option
# names in the manpage.
#
# For help on each option: `man zshoptions(1)`

# Let us `cd` into a directory just by typing its name, without `cd`.
#
# Only works when `SHIN_STDIN` (SHell INput STanDard INput) is set, i.e. when the
# commands are being read from standard input, i.e. in interactive use.
setopt AUTO_CD

# Make `cd` push the old directory onto the directory stack.
setopt AUTO_PUSHD

# Try to correct the spelling of commands.
setopt CORRECT

# Try to correct the spelling of all arguments in a line.
setopt CORRECT_ALL

# Do not display a line previously found.
setopt HIST_FIND_NO_DUPS

# Don't record an entity that was just recorded again.
setopt HIST_IGNORE_DUPS

# Don't record an entry starting with a space.
setopt HIST_IGNORE_SPACE

# Whenever the user enters a line with history expansion, don't execute the
# line directly; instead, perform history expansion and reload the line into
# the editing buffer.
setopt HIST_VERIFY

# Do not exit on end-of-file (pressing `<C-d>`). Requires the use of `exit`
# or `logout` instead.
setopt IGNORE_EOF

# Add new history lines incrementally (as soon as they are entered), rather
# than waiting until the shell exists.
setopt INC_APPEND_HISTORY

# Allow comments even in interactive shells.
setopt INTERACTIVE_COMMENTS

# All unquoted arguments of the form `anything=expression` appearing after the
# command name have filename expansion performed.
#
#   % echo var=~/dotfiles
#     var=~/dotfiles
#
#   % echo var=~/dotfiles
#     var=/Users/name/dotfiles
setopt MAGIC_EQUAL_SUBST

# On an ambiguous completion, instead of listing possibilities, insert the
# first match immediately. This makes us enter the menu in a single Tab,
# instead of 2.
setopt MENU_COMPLETE

# Don't push multiple copies of the same directory onto the directory stack.
setopt PUSHD_IGNORE_DUPS

# Share history between all sessions.
setopt SHARE_HISTORY

# Plugins {{{1

# Source fzf config which includes fuzzy completion and key-bindings.
#
# Do NOT edit this line! The installer can recognize the presence of this line
# and avoid duplication.
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Initialize pyenv.
eval "$(pyenv init -)"

# Prompt
#
# https://github.com/starship/starship
eval "$(starship init zsh)"

# Sourcing {{{1

# Source zsh specific functions and aliases.
#
# There's no point in having {ba,z}sh compatibility which would not allow us to
# use the set of features specific to zsh.
source "${HOME}/dotfiles/zsh/lib/aliases.zsh"

# Key Bindings {{{1
#
# In kitty, one can find the sequence of characters the terminal sends to the
# program for a certain key combination using `kitty +kitten show_key`.

# When we hit `C-w`, don't delete back to a space, but to a space *or* a slash.
# Useful to have more control over deletion on a filepath.
#
# See:
# - http://stackoverflow.com/a/1438523
# - http://stackoverflow.com/a/11200998
# - `man zshcontrib(1)` /select-word-style
autoload -Uz select-word-style
select-word-style bash

# Use S-Tab to cycle backward during a completion
bindkey '\e[Z' reverse-menu-complete
#        ├──┘
#        └ the shell doesn't seem to recognize the keysym "S-Tab" but when we
#          press "S-Tab", the terminal sends the sequence "^[[Z" or "ESC [ Z",
#          so we use it in the lhs of our mapping.

# The delete key doesn't work in zsh. I use `C-d` but still let's just fix it.
bindkey '\e[3~' delete-char

# Search backward/forward in the history for a line beginning with the current
# line up to the cursor. This leaves the cursor in its original position.
#
# By default, `C-p/C-n` are bound to `up-line-or-history/down-line-or-history`.
#
# See:
#     man zshcontrib
#     /down-line-or-beginning-search
#     /up-line-or-beginning-search
bindkey '^P' history-beginning-search-backward
bindkey '^N' history-beginning-search-forward

# By default, C-u deletes the whole line (kill-whole-line).
# bindkey '^U' backward-kill-line

# Remap `C-l` to both scroll the current screen contents into the scrollback
# buffer and clear the screen, instead of just clearing the screen.
#
# Source:
# https://sw.kovidgoyal.net/kitty/conf/#shortcut-kitty.Reset-the-terminal
scroll-and-clear-screen() {
  printf '\n%.0s' {1..$LINES}
  zle clear-screen
}
zle -N scroll-and-clear-screen
bindkey '^L' scroll-and-clear-screen

# Automatic history expansion (`!!`) when inserting a space.
bindkey ' ' magic-space

# Edit the command line using the VISUAL editor.
autoload -Uz edit-command-line
zle -N edit-command-line
bindkey '^X^E' edit-command-line

# Press `C-x H`, then some key combination for which you want the name of the
# zle function which is invoked, like `C-x h`, and you'll see something like:
#
#     "^Xh" is describe-key-briefly
bindkey '^Xh' describe-key-briefly

# Abbreviations {{{1

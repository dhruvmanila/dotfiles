#!/usr/bin/env bash
# This script was generated by bashly 1.1.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dotbot_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot - Personal tool for managing dotfiles and packages\n"
    echo

  else
    printf "dotbot - Personal tool for managing dotfiles and packages\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot COMMAND\n"
  printf "  dotbot [COMMAND] --help | -h\n"
  printf "  dotbot --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   symlink dotfiles after backing up the existing ones\n" "link   "
  printf "  %s   setup the default shell for the current user\n" "shell  "
  printf "  %s   setup a new mac machine the way I like it\n" "setup  "
  printf "  %s   sync lib files with global package list\n" "sync   "
  printf "  %s   upgrade packages\n" "upgrade"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dotbot_link_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot link - symlink dotfiles after backing up the existing ones\n"
    echo

  else
    printf "dotbot link - symlink dotfiles after backing up the existing ones\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot link [OPTIONS]\n"
  printf "  dotbot link --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    skip backup for the existing dotfiles\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dotbot_shell_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot shell\n"
    echo

    printf "  setup the default shell for the current user\n  \n  Default shell path: \"$DEFAULT_SHELL_PATH\"\n"
    echo

  else
    printf "dotbot shell - setup the default shell for the current user\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot shell\n"
  printf "  dotbot shell --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dotbot_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot setup - setup a new mac machine the way I like it\n"
    echo

  else
    printf "dotbot setup - setup a new mac machine the way I like it\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot setup\n"
  printf "  dotbot setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dotbot_sync_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot sync - sync lib files with global package list\n"
    echo

  else
    printf "dotbot sync - sync lib files with global package list\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot sync [OPTIONS]\n"
  printf "  dotbot sync --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--brew, -b"
    printf "    sync only homebrew packages\n    File: $HOMEBREW_BUNDLE_FILE\n"
    echo

    # :flag.usage
    printf "  %s\n" "--node, -n"
    printf "    sync only node packages\n    File: $NPM_GLOBAL_PACKAGES\n"
    echo

    # :flag.usage
    printf "  %s\n" "--python, -p"
    printf "    sync only Python packages\n    File: $PYTHON_GLOBAL_REQUIREMENTS\n"
    echo

    # :flag.usage
    printf "  %s\n" "--cargo, -c"
    printf "    sync only Cargo packages\n    File: $CARGO_GLOBAL_PACKAGES\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dotbot_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot upgrade - upgrade packages\n"
    echo

  else
    printf "dotbot upgrade - upgrade packages\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot upgrade [PACKAGE] [OPTIONS]\n"
  printf "  dotbot upgrade --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ref, -r REF"
    printf "    Upgrade to a specific ref (commit/branch/tag). This flag is applicable only\n    when 'PACKAGE' is:\n      - neovim\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PACKAGE"
    printf "    package to upgrade\n"
    printf "    Allowed: all, brew, cargo, mac, neovim, nnn, npm, plugins, python\n"
    printf "    Default: all\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
#
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# src/lib/log.sh
# Helper functions to log to stdout with colors and indicators.

header() {
  bold "==> $1"
}

error() {
  red_bold "[✗] $1"
}

warning() {
  yellow_bold "[!] $1"
}

# src/lib/setup.sh
declare -a PY_NEOVIM_PACKAGES=(
  "pynvim"
  "debugpy"
)

declare -A SYMLINKS=(
  [".editorconfig"]=".editorconfig"
  ["bash/bash_profile"]=".bash_profile"
  ["bash/bashrc"]=".bashrc"
  ["bat"]=".config/bat"
  ["bottom"]="Library/Application Support/bottom"
  ["bpytop"]=".config/bpytop"
  ["gh/config.yml"]=".config/gh/config.yml"
  ["git/config"]=".gitconfig"
  ["git/message"]=".gitmessage"
  ["glow"]="Library/Preferences/glow"
  ["gpg/gpg-agent.conf"]=".gnupg/gpg-agent.conf"
  ["gpg/gpg.conf"]=".gnupg/gpg.conf"
  ["grip"]=".config/grip"
  ["hammerspoon"]=".hammerspoon"
  ["himalaya"]=".config/himalaya"
  ["htop"]=".config/htop"
  ["ignore"]=".ignore"
  ["inputrc"]=".inputrc"
  ["ipython/ipython_config.py"]=".ipython/profile_default/ipython_config.py"
  ["ipython/startup"]=".ipython/profile_default/startup"
  ["jupyter/jupyter_lab_config.py"]=".jupyter/jupyter_lab_config.py"
  ["jupyter/jupyter_notebook_config.py"]=".jupyter/jupyter_notebook_config.py"
  ["jupyter/lab/user-settings"]=".jupyter/lab/user-settings"
  ["karabiner"]=".config/karabiner"
  ["kitty"]=".config/kitty"
  ["nvim"]=".config/nvim"
  ["pip"]=".config/pip"
  ["pypoetry"]="Library/Application Support/pypoetry"
  ["ssh/config"]=".ssh/config"
  ["starship.toml"]=".config/starship.toml"
  ["tmux/tmux.conf"]=".tmux.conf"
  ["vim"]=".vim"
  ["vim/vimrc"]=".vimrc"
  ["youtube-dl"]=".config/youtube-dl"
  ["zsh/zshenv"]=".zshenv"
  ["zsh/zshrc"]=".zshrc"
)

download_dotfiles() { # {{{1
  header "Downloading the dotfiles..."
  mkdir -p "${DOTFILES_DIRECTORY}"
  curl -fsSLo ~/dotfiles.tar.gz https://github.com/dhruvmanila/dotfiles/tarball/master

  header "Extracting the dotfiles..."
  tar -zxf "${HOME}/dotfiles.tar.gz" --strip-components 1 -C "${DOTFILES_DIRECTORY}"
  rm -rf ~/dotfiles.tar.gz
}

install_cargo_packages() { # {{{1
  header "Installing global cargo packages from ${CARGO_GLOBAL_PACKAGES}..."
  while IFS= read -r package; do
    cargo install "$package"
  done < "${CARGO_GLOBAL_PACKAGES}"
}

install_homebrew() { # {{{1
  header "Installing Homebrew..."
  set +e
  if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"; then
    error "Failure occured during Homebrew installation"
    # https://github.com/Homebrew/brew/pull/9383
    core_location="/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core"

    header "Checking if homebrew-core is a shallow clone..."
    if [[ -f "${core_location}/.git/shallow" ]]; then
      header "Fetching everything from homebrew/homebrew-core (this may take a while)..."

      # This `git` is from the xcode command-line tools. By default, we will
      # be using the brew installed `git` to keep up-to date.
      git -C $core_location fetch --unshallow
    else
      error "Unknown error while installing homebrew, exiting..."
      exit 1
    fi
  fi
  set -e
}

install_homebrew_packages() { # {{{1
  header "Installing homebrew bundle tap..."
  brew tap homebrew/bundle

  header "Installing packages from Brewfile..."
  #  prints output from commands as they are run ┐
  #                                              │
  HOMEBREW_NO_AUTO_UPDATE=1 brew bundle install -v --no-lock --file "$HOMEBREW_BUNDLE_FILE"
  #                                                  │
  #         don't output a `Brewfile.lock.json` file ┘

  header "Cleaning up..."
  brew cleanup
}

install_npm_global_packages() { # {{{1
  header "Installing global npm packages from ${NPM_GLOBAL_PACKAGES}..."
  while IFS= read -r package; do
    npm --location=global install "$package"
  done < "${NPM_GLOBAL_PACKAGES}"
}

install_python() { # {{{1
  # Setup the mentioned Python versions in from the constant $PYTHON_VERSIONS.
  # The first element is made the global Python version.
  #
  # If the version is already installed, it will be skipped. `pip` will be
  # upgraded for every mentioned version.
  for python_version in "${PYTHON_VERSIONS[@]}"; do
    if ! pyenv versions | grep -q "${python_version}"; then
      header "Installing Python ${python_version}..."
      pyenv install "${python_version}"
    else
      header "Python $python_version is already installed."
    fi
    header "Upgrading pip for Python ${python_version}..."
    "$(pyenv root)/versions/${python_version}/bin/pip" install --upgrade pip
  done

  pyenv_global_python="${PYTHON_VERSIONS[0]}"
  header "Making ${pyenv_global_python} as the global Python version..."
  pyenv global "${pyenv_global_python}"

  header "Initiating pyenv..."
  eval "$(pyenv init -)"
  eval "$(pyenv init --path)"
}

install_python_global_packages() { # {{{1
  header "Installing pipx to manage global packages..."
  python -m pip install pipx
  pyenv rehash

  header "Installing global Python packages from ${PYTHON_GLOBAL_REQUIREMENTS}..."
  while IFS= read -r package; do
    if [[ "$package" == "jupyter" ]]; then
      # 'jupyter' is a metapackage used for installation of all packages related
      # to the ecosystem.
      pipx install --include-deps "$package"

      # These packages needs to be injected in the same environment.
      pipx inject --include-apps "$package" jupyterlab
      pipx inject --include-apps "$package" jupytext
    else
      pipx install "$package"
    fi
  done < "${PYTHON_GLOBAL_REQUIREMENTS}"
}

install_xcode_command_line_tools() { # {{{1
  header "Installing xcode command line tools..."
  xcode-select --install
  # wait until the tools are installed...
  until xcode-select -p &> /dev/null; do
    sleep 5
  done
}

setup_aws() { # {{{1
  # This is the recommended way of installing the tool.
  # https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html#cliv2-mac-install-cmd
  curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"

  # This requires root permission to create symlinks between `path/to/aws-cli/*`
  # and `/usr/local/bin/*` where '*' indicates the necessary executables.
  sudo installer -pkg AWSCLIV2.pkg -target /

  rm AWSCLIV2.pkg
}

setup_dotfiles_git_repository() { # {{{1
  header "Initializing Git repository..."
  set -x
  git init
  git remote add origin https://github.com/dhruvmanila/dotfiles
  git fetch --all
  git reset --hard FETCH_HEAD
  git branch --set-upstream-to origin/master master
  set +x
}

setup_github_ssh() { # {{{1
  # NOTE: This function should be called after symlinking the dotfiles
  ssh -T git@github.com &> /dev/null
  if [[ $? -eq 1 ]]; then
    return
  fi

  local ssh_algorithm="ed25519"
  local ssh_filename="github"

  header "Generating SSH keys..."
  ask "Please provide an email address"
  ssh-keygen -f "${HOME}/.ssh/${ssh_filename}" -t "$ssh_algorithm" -C "$REPLY"

  # shellcheck disable=SC1090
  source "$(ssh-agent)"
  header "Adding SSH key to the ssh-agent..."
  ssh-add -K "${HOME}/.ssh/${ssh_filename}"

  header "Copied public SSH key to clipboard. Please add it to GitHub.com..."
  pbcopy < "${HOME}/.ssh/${ssh_filename}.pub"
  open "https://github.com/settings/ssh"
  for i in {1..6}; do
    ssh -T git@github.com &> /dev/null
    if [[ $? -eq 1 ]]; then
      header "Authentication successful."
      break
    else
      if [[ i -eq 6 ]]; then
        error "Exceeded max retries. Authenticate using 'ssh -T git@github.com' command."
        break
      fi
      error "Failed to authenticate. Retrying in 5 seconds..."
    fi
    sleep 5
  done
}

setup_neovim_nightly() { # {{{1
  header "Setting up Neovim nightly..."
  git clone --depth=1 git@github.com:dhruvmanila/neovim.git "$NEOVIM_DIRECTORY"
  (
    cd "$NEOVIM_DIRECTORY" || exit 1
    git checkout master
    git remote add upstream git@github.com:neovim/neovim.git
    build_neovim
  )
  header "Setting up Neovim Python environment..."
  (
    cd ~/.neovim || exit 1
    python3 -m venv --prompt pynvim .venv
    source venv/bin/activate
    pip3 install "${PY_NEOVIM_PACKAGES[*]}"
    deactivate
  )
}

setup_nnn() { # {{{1
  header "Setting up nnn..."
  git clone git@github.com:jarun/nnn.git "$NNN_DIRECTORY"
  (
    cd "$NNN_DIRECTORY" || exit 1
    git fetch origin --tags --force
    git checkout "$(git describe --abbrev=0)"
    build_nnn
  )
}

setup_symlinks() { # {{{1
  # What does this file do? {{{
  #
  #   > Immediately after logging a user in, login displays the system copyright
  #   > notice, the date and time the user last logged in, the message of the day
  #   > as well as other information. If the file .hushlogin exists in the user's
  #   > home directory, all of these messages are suppressed.
  #
  # Source: `man login`
  # }}}
  if [[ ! -f "${HOME}/.hushlogin" ]]; then
    touch ~/.hushlogin
  fi

  # Create the necessary symbolic links between the `dotfiles` and `HOME` directory.
  header "Creating the necessary symlinks..."

  #                ┌ list associative array keys
  #                │
  for source in "${!SYMLINKS[@]}"; do
    link "$source" "${SYMLINKS[$source]}"
  done
}

setup_tmux_plugins() { # {{{1
  header "Installing tmux plugin manager..."
  git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm

  header "Installing tmux plugins..."
  ~/.tmux/plugins/tpm/bin/install_plugins
}

# }}}1

# src/lib/upgrade.sh
upgrade_all() { # {{{1
  upgrade_brew
  upgrade_plugins
  upgrade_npm
  upgrade_python
  upgrade_neovim "$@"
  upgrade_nnn
  upgrade_mac
}

upgrade_brew() { # {{{1
  header "Updating homebrew..."
  brew update

  header "Upgrading homebrew packages..."
  brew upgrade

  header "Upgrading outdated casks..."
  brew upgrade --cask --greedy

  # Remove all cache files older than one day
  header "Cleaning up..."
  brew cleanup --prune 1
}

upgrade_cargo() { # {{{1
  header "Upgrading global cargo packages..."
  while IFS= read -r package; do
    # The `install` command updates the package if there is a newer version.
    cargo install "$package"
  done < "${CARGO_GLOBAL_PACKAGES}"
}

upgrade_mac() { # {{{1
  header "Upgrading macOS applications..."
  mas upgrade

  header "Finding available software..."
  output="$(softwareupdate --list 2>&1)"
  if (($? > 0)) && [[ "$output" = *"No new software available"* ]]; then
    echo "No new software available."
  else
    echo "$output"
    seek_confirmation "A system update is available. Do you wish to install it?"
    if is_confirmed; then
      softwareupdate --install --all
    fi
  fi
}

upgrade_neovim() { # {{{1
  header "Upgrading Neovim to ${1:-"the latest commit on master"}..."
  (
    cd "$NEOVIM_DIRECTORY" || exit 1
    curr_hash=$(git rev-parse HEAD)

    # Pull the latest changes
    git checkout master
    git pull upstream master
    git push origin master
    git fetch upstream --tags --force
    if [[ -n $1 ]]; then
      git checkout "$1"
    fi

    new_hash=$(git rev-parse HEAD)
    if [[ "$curr_hash" == "$new_hash" ]]; then
      seek_confirmation "Neovim seems to be already up to date"
      if ! is_confirmed; then
        return
      fi
    fi

    build_neovim
  )
}

upgrade_nnn() { # {{{1
  header "Upgrading nnn to the latest version..."
  (
    cd "$NNN_DIRECTORY" || exit 1
    current_tag="$(git describe --abbrev=0)"
    git checkout master
    git pull origin master
    git fetch origin --tags --force
    latest_tag="$(git describe --abbrev=0)"
    if [[ "$current_tag" == "$latest_tag" ]]; then
      echo "==> nnn is already up to date to $latest_tag"
      return
    fi
    git checkout "$latest_tag"
    build_nnn
  )

  # https://github.com/jarun/nnn/tree/master/plugins#installation
  header "Upgrading nnn plugins..."
  sh -c "$(curl -Ls https://raw.githubusercontent.com/jarun/nnn/master/plugins/getplugs)"
}

upgrade_npm() { # {{{1
  header "Upgrading npm and packages..."
  npm --location=global install npm@latest
  npm --location=global upgrade
}

upgrade_plugins() { # {{{1
  # Not quiting vim/neovim to check what's new
  header "Upgrading vim plugins..."
  vim +PlugUpgrade +PlugClean +PlugUpdate

  # header "Upgrading neovim plugins..."
  # nvim +Lazy sync

  header "Cleaning and updating tmux plugins..."
  ~/.tmux/plugins/tpm/bin/clean_plugins
  ~/.tmux/plugins/tpm/bin/update_plugins all
}

upgrade_python() { # {{{1
  header "Upgrading pip for all pyenv Python versions..."
  for python_exec in "$PYENV_ROOT"/versions/*/bin/python; do
    $python_exec -m pip install --upgrade pip
  done

  header "Upgrading pipx..."
  "$PYENV_ROOT/bin/python" -m pip install --upgrade pipx

  header "Upgrading all Python global packages..."
  pipx upgrade-all --include-injected
}

# }}}1

# src/lib/utils.sh
ask() { # {{{1
  yellow_bold "[?] $1"
  read -r -p "$(bold "> ")"
}

build_neovim() { # {{{1
  make distclean
  make \
    CMAKE_BUILD_TYPE="${NEOVIM_BUILD_TYPE:-"Release"}" \
    CMAKE_EXTRA_FLAGS="-DCMAKE_INSTALL_PREFIX=$NEOVIM_INSTALL_DIRECTORY"
  make install
}

build_nnn() { # {{{1
  make uninstall
  make O_NERD=1 install
}

command_exists() { # {{{1
  command -v "$1" &> /dev/null
}

function_exists() { # {{{1
  [[ "$(type -t "$1")" == "function" ]]
}

get_jupyter_app_dir() { # {{{1
  printf "%s" "$(jupyter lab path \
    | awk -F ':[ ]+' '{ if($1 == "Application directory") {print $2} }')"
}

is_confirmed() { # {{{1
  [[ "$REPLY" =~ ^[Yy]$ ]]
}

is_git_repo() { # {{{1
  git rev-parse --is-inside-work-tree &> /dev/null
}

link() { # {{{1
  local source_file="${DOTFILES_DIRECTORY}/config/${1}"
  local target_file="${HOME}/${2}"
  if ! [[ -e "$target_file" ]]; then
    echo "==> $target_file -> $source_file"
    ln -fs "$source_file" "$target_file"
  fi
}

seek_confirmation() { # {{{1
  warning "$1"
  read -r -p "$(bold "[y/n] ")" -n 1
  printf "\n"
}

setup_required_directories() { # {{{1
  for directory in "${REQUIRED_DIRECTORIES[@]}"; do
    if ! [[ -d $directory ]]; then
      mkdir -p "$directory"
      if [[ -z $1 ]]; then
        echo "==> Created $directory"
      fi
    fi
  done
}

# }}}1

# :command.command_functions
# :command.function
dotbot_link_command() {
  # src/link_command.sh
  # shellcheck disable=SC2154
  force=${args[--force]}

  if ! [[ $force ]]; then
    declare -i count=0
    backup_dir="${HOME}/dotfiles_$(date +"%Y_%m_%dT%H_%M_%S").backup"
    mkdir "$backup_dir"

    for location in "${BACKUP_DOTFILES[@]}"; do
      if [[ -f $location || -d $location ]]; then
        cp -R "$location" "$backup_dir"
        ((count += 1))
      fi
    done

    if ((count > 0)); then
      header "Created backup in ${backup_dir}"
    else
      header "Skipped backup as there are no dotfiles"
      rm -rf "$backup_dir"
    fi
  fi

  setup_symlinks

}

# :command.function
dotbot_shell_command() {
  # src/shell_command.sh
  # Setup the default shell as mentioned in the DEFAULT_SHELL_PATH global
  # variable. This will be skipped if the shell is already the default one.

  # https://stackoverflow.com/a/41553295
  if dscl . -read ~/ UserShell | grep "$DEFAULT_SHELL_PATH" &> /dev/null; then
    header "'$DEFAULT_SHELL_PATH' is already the default shell."
    return
  fi

  if ! grep -F -q "${DEFAULT_SHELL_PATH}" /etc/shells; then
    header "Adding '$DEFAULT_SHELL_PATH' to /etc/shells..."
    echo "${DEFAULT_SHELL_PATH}" | sudo tee -a /etc/shells
  fi

  header "Switching to '${DEFAULT_SHELL_PATH}' as the default shell..."
  chsh -s "${DEFAULT_SHELL_PATH}"

}

# :command.function
dotbot_setup_command() {
  # src/setup_command.sh
  seek_confirmation "'setup' command should only be invoked on a fresh setup"
  if ! is_confirmed; then
    exit
  fi

  setup_required_directories

  if ! [[ -d "$DOTFILES_DIRECTORY" ]]; then
    download_dotfiles
  fi

  header "Changing directory to $DOTFILES_DIRECTORY..."
  cd "$DOTFILES_DIRECTORY" || exit 1

  if ! xcode-select -p &> /dev/null; then
    install_xcode_command_line_tools
  fi

  if ! command_exists 'brew'; then
    install_homebrew
  fi
  install_homebrew_packages

  if ! is_git_repo; then
    setup_dotfiles_git_repository
  fi

  install_python
  install_python_global_packages
  install_global_npm_packages
  install_cargo_packages

  setup_aws

  setup_neovim_nightly

  # No backup as this is a fresh setup
  setup_symlinks

  setup_tmux_plugins
  setup_github_ssh

  update_macos_settings
  update_macos_dock

}

# :command.function
dotbot_sync_command() {
  # src/sync_command.sh
  # shellcheck disable=SC2154
  sync_brew=${args[--brew]}
  sync_node=${args[--node]}
  sync_python=${args[--python]}
  sync_cargo=${args[--cargo]}

  # If there are no arguments, then the default behavior is to sync all files.
  if [[ -z ${args[*]} ]]; then
    sync_all=1
  fi

  if [[ $sync_all || $sync_brew ]]; then
    header "Syncing Brewfile with the currently installed packages..."
    HOMEBREW_NO_AUTO_UPDATE=1 brew bundle dump -f --describe
  fi

  if [[ $sync_all || $sync_python ]]; then
    header "Syncing requirements.txt with the global Python packages..."
    pipx list --json \
      | jq --raw-output '.venvs | keys | join("\n")' \
        > "${PYTHON_GLOBAL_REQUIREMENTS}"
  fi

  if [[ $sync_all || $sync_node ]]; then
    header "Syncing node_modules.txt with the global Node packages..."
    npm --location=global --json list \
      | jq --raw-output '.dependencies | del(."instant-markdown-d") | keys | join("\n")' \
        > "${NPM_GLOBAL_PACKAGES}"
  fi

  if [[ $sync_all || $sync_cargo ]]; then
    header "Syncing cargo_packages.txt with the global Cargo packages..."
    cargo install --list \
      | awk -F ' ' '{ if(NR % 2 == 1) {print $1} }' \
        > "${CARGO_GLOBAL_PACKAGES}"
  fi

}

# :command.function
dotbot_upgrade_command() {
  # src/upgrade_command.sh
  # shellcheck disable=SC2154
  package="${args[package]}"
  ref="${args[--ref]}"
  handler="upgrade_$package"

  if function_exists "$handler"; then
    $handler "$ref"
  else
    error "Invalid package: $package"
    exit 1
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dotbot_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    link)
      action="link"
      shift
      dotbot_link_parse_requirements "$@"
      shift $#
      ;;

    shell)
      action="shell"
      shift
      dotbot_shell_parse_requirements "$@"
      shift $#
      ;;

    setup)
      action="setup"
      shift
      dotbot_setup_parse_requirements "$@"
      shift $#
      ;;

    sync)
      action="sync"
      shift
      dotbot_sync_parse_requirements "$@"
      shift $#
      ;;

    upgrade)
      action="upgrade"
      shift
      dotbot_upgrade_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      dotbot_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotbot_link_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotbot_link_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="link"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotbot_shell_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotbot_shell_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="shell"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotbot_setup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotbot_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotbot_sync_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotbot_sync_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sync"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --brew | -b)

        # :flag.case_no_arg
        args['--brew']=1
        shift
        ;;

      # :flag.case
      --node | -n)

        # :flag.case_no_arg
        args['--node']=1
        shift
        ;;

      # :flag.case
      --python | -p)

        # :flag.case_no_arg
        args['--python']=1
        shift
        ;;

      # :flag.case
      --cargo | -c)

        # :flag.case_no_arg
        args['--cargo']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dotbot_upgrade_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotbot_upgrade_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="upgrade"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ref | -r)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ref']="$2"
          shift
          shift
        else
          printf "%s\n" "--ref requires an argument: --ref, -r REF" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['package']+x} ]]; then

          args['package']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['package']:-} ]] || args['package']="all"

  # :command.whitelist_filter
  if [[ -n ${args['package']} ]] && [[ ! ${args['package']} =~ ^(all|brew|cargo|mac|neovim|nnn|npm|plugins|python)$ ]]; then
    printf "%s\n" "package must be one of: all, brew, cargo, mac, neovim, nnn, npm, plugins, python" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh
  # shellcheck disable=SC2034
  #
  # Code here runs inside the `initialize()` function
  #
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  #
  #     > DOTFILES_DIRECTORY="${HOME}/dotfiles"
  #
  # Feel free to empty (but not delete) this file.

  case "$(uname)" in
    Darwin) ;;
    *)
      error "'dot' command is only supported on a mac machine"
      exit 1
      ;;
  esac

  HOMEBREW_PREFIX="${HOMEBREW_PREFIX:-$(brew --prefix)}"

  # Default shell path. This can be set using `dot shell`.
  DEFAULT_SHELL_PATH="${HOMEBREW_PREFIX}/bin/zsh"

  # Common directories
  DOTFILES_DIRECTORY="${HOME}/dotfiles"
  NEOVIM_DIRECTORY="${HOME}/contributing/neovim"
  NEOVIM_INSTALL_DIRECTORY="${HOME}/neovim"
  NNN_DIRECTORY="${HOME}/git/nnn"

  # Python versions to be installed on the system.
  # First version will be the global one
  PYTHON_VERSIONS=(
    "3.10.2"
    "3.9.10"
  )

  # Packages file
  PACKAGE_DIR="${DOTFILES_DIRECTORY}/src/package"
  HOMEBREW_BUNDLE_FILE="${PACKAGE_DIR}/Brewfile"
  PYTHON_GLOBAL_REQUIREMENTS="${PACKAGE_DIR}/requirements.txt"
  NPM_GLOBAL_PACKAGES="${PACKAGE_DIR}/node_modules.txt"
  CARGO_GLOBAL_PACKAGES="${PACKAGE_DIR}/cargo_packages.txt"

  # On initialization of the script, if these directories does not exist, then
  # they will be created.
  REQUIRED_DIRECTORIES=(
    ~/.config
    ~/.gnupg
    ~/.ssh
    ~/contributing
    ~/git
    ~/neovim
    ~/playground
    ~/projects
    ~/work
  )

  # These files/directories will be backed up before symlinking, if they exists.
  # This step can be skipped if `-f/--force` flag is passed to the `link` command.
  BACKUP_DOTFILES=(
    ~/.bash_profile
    ~/.bashrc
    ~/.config
    ~/.gitconfig
    ~/.inputrc
    ~/.tmux.conf
    ~/.vim
  )

  setup_required_directories silent

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "link") dotbot_link_command ;;
    "shell") dotbot_shell_command ;;
    "setup") dotbot_setup_command ;;
    "sync") dotbot_sync_command ;;
    "upgrade") dotbot_upgrade_command ;;
  esac
}

initialize
run "$@"

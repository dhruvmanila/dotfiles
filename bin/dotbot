#!/usr/bin/env bash
# This script was generated by bashly 1.1.10 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

version_command() {
  echo "$version"
}

dotbot_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot - Personal tool for managing dotfiles and packages\n"
    echo

  else
    printf "dotbot - Personal tool for managing dotfiles and packages\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot COMMAND\n"
  printf "  dotbot [COMMAND] --help | -h\n"
  printf "  dotbot --version | -v\n"
  echo

  printf "%s\n" "Commands:"
  printf "  %s   sync lib files with global package list\n" "sync   "
  printf "  %s   upgrade packages\n" "upgrade"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

dotbot_sync_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot sync - sync lib files with global package list\n"
    echo

  else
    printf "dotbot sync - sync lib files with global package list\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot sync [OPTIONS]\n"
  printf "  dotbot sync --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--brew, -b"
    printf "    sync only homebrew packages\n    File: $HOMEBREW_BUNDLE_FILE\n"
    echo

    printf "  %s\n" "--node, -n"
    printf "    sync only node packages\n    File: $NPM_GLOBAL_PACKAGES\n"
    echo

    printf "  %s\n" "--python, -p"
    printf "    sync only Python packages\n    File: $PYTHON_GLOBAL_REQUIREMENTS\n"
    echo

    printf "  %s\n" "--cargo, -c"
    printf "    sync only Cargo packages\n    File: $CARGO_GLOBAL_PACKAGES\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

dotbot_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "dotbot upgrade - upgrade packages\n"
    echo

  else
    printf "dotbot upgrade - upgrade packages\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dotbot upgrade [PACKAGE] [OPTIONS]\n"
  printf "  dotbot upgrade --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--ref, -r REF"
    printf "    Upgrade to a specific ref (commit/branch/tag). This flag is applicable only\n    when 'PACKAGE' is:\n      - neovim\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "PACKAGE"
    printf "    package to upgrade\n"
    printf "    Allowed: all, brew, cargo, neovim, nnn, npm, plugins, python\n"
    printf "    Default: all\n"
    echo

  fi
}

normalize_input() {
  local arg flags passthru
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
#
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# Helper functions to log to stdout with colors and indicators.

header() {
  bold "==> $1"
}

error() {
  red_bold "[âœ—] $1"
}

warning() {
  yellow_bold "[!] $1"
}

upgrade_all() {
  upgrade_brew
  upgrade_plugins
  upgrade_npm
  upgrade_python
  upgrade_neovim "$@"
  upgrade_nnn
}

upgrade_brew() {
  header "Updating homebrew..."
  brew update

  header "Upgrading homebrew packages..."
  brew upgrade

  header "Upgrading outdated casks..."
  brew upgrade --cask --greedy

  # Remove all cache files older than one day
  header "Cleaning up..."
  brew cleanup --prune 1
}

upgrade_cargo() {
  header "Upgrading global cargo packages..."
  while IFS= read -r package; do
    # The `install` command updates the package if there is a newer version.
    cargo install "$package"
  done < "${CARGO_GLOBAL_PACKAGES}"
}

upgrade_neovim() {
  header "Upgrading Neovim to ${1:-"the latest commit on master"}..."
  (
    cd "$NEOVIM_DIRECTORY" || exit 1
    curr_hash=$(git rev-parse HEAD)

    # Pull the latest changes
    git checkout master
    git pull upstream master
    git push origin master
    git fetch upstream --tags --force
    if [[ -n $1 ]]; then
      git checkout "$1"
    fi

    new_hash=$(git rev-parse HEAD)
    if [[ "$curr_hash" == "$new_hash" ]]; then
      seek_confirmation "Neovim seems to be already up to date"
      if ! is_confirmed; then
        return
      fi
    fi

    build_neovim
  )
}

upgrade_nnn() {
  header "Upgrading nnn to the latest version..."
  (
    cd "$NNN_DIRECTORY" || exit 1
    current_tag="$(git describe --abbrev=0)"
    git checkout master
    git pull origin master
    git fetch origin --tags --force
    latest_tag="$(git describe --abbrev=0)"
    if [[ "$current_tag" == "$latest_tag" ]]; then
      echo "==> nnn is already up to date to $latest_tag"
      return
    fi
    git checkout "$latest_tag"
    build_nnn
  )

  # https://github.com/jarun/nnn/tree/master/plugins#installation
  header "Upgrading nnn plugins..."
  sh -c "$(curl -Ls https://raw.githubusercontent.com/jarun/nnn/master/plugins/getplugs)"
}

upgrade_npm() {
  header "Upgrading npm and packages..."
  npm --location=global install npm@latest
  npm --location=global upgrade
}

upgrade_plugins() {
  # Not quiting vim/neovim to check what's new
  header "Upgrading vim plugins..."
  vim +PlugUpgrade +PlugClean +PlugUpdate

  # header "Upgrading neovim plugins..."
  # nvim +Lazy sync

  header "Cleaning and updating tmux plugins..."
  ~/.tmux/plugins/tpm/bin/clean_plugins
  ~/.tmux/plugins/tpm/bin/update_plugins all
}

upgrade_python() {
  header "Upgrading pip for all pyenv Python versions..."
  for python_exec in "$PYENV_ROOT"/versions/*/bin/python; do
    $python_exec -m pip install --upgrade pip
  done

  header "Upgrading pipx..."
  "$PYENV_ROOT/bin/python" -m pip install --upgrade pipx

  header "Upgrading all Python global packages..."
  pipx upgrade-all --include-injected
}

ask() {
  yellow_bold "[?] $1"
  read -r -p "$(bold "> ")"
}

build_neovim() {
  make distclean
  make \
    CMAKE_BUILD_TYPE="${NEOVIM_BUILD_TYPE:-"Release"}" \
    CMAKE_EXTRA_FLAGS="-DCMAKE_INSTALL_PREFIX=${NEOVIM_INSTALL_DIRECTORY:-"${HOME}/neovim"}"
  make install
}

build_nnn() {
  make uninstall
  make O_NERD=1 install
}

function_exists() {
  [[ "$(type -t "$1")" == "function" ]]
}

is_confirmed() {
  [[ "$REPLY" =~ ^[Yy]$ ]]
}

seek_confirmation() {
  warning "$1"
  read -r -p "$(bold "[y/n] ")" -n 1
  printf "\n"
}

dotbot_sync_command() {
  # shellcheck disable=SC2154
  sync_brew=${args[--brew]}
  sync_node=${args[--node]}
  sync_python=${args[--python]}
  sync_cargo=${args[--cargo]}

  # If there are no arguments, then the default behavior is to sync all files.
  if [[ -z ${args[*]} ]]; then
    sync_all=1
  fi

  if [[ $sync_all || $sync_brew ]]; then
    header "Syncing Brewfile with the currently installed packages..."
    HOMEBREW_NO_AUTO_UPDATE=1 brew bundle dump -f --describe
  fi

  if [[ $sync_all || $sync_python ]]; then
    header "Syncing requirements.txt with the global Python packages..."
    pipx list --json \
      | jq --raw-output '.venvs | keys | join("\n")' \
        > "${PYTHON_GLOBAL_REQUIREMENTS}"
  fi

  if [[ $sync_all || $sync_node ]]; then
    header "Syncing node_modules.txt with the global Node packages..."
    npm --location=global --json list \
      | jq --raw-output '.dependencies | del(."instant-markdown-d") | keys | join("\n")' \
        > "${NPM_GLOBAL_PACKAGES}"
  fi

  if [[ $sync_all || $sync_cargo ]]; then
    header "Syncing cargo_packages.txt with the global Cargo packages..."
    cargo install --list \
      | awk -F ' ' '{ if(NR % 2 == 1) {print $1} }' \
        > "${CARGO_GLOBAL_PACKAGES}"
  fi

}

dotbot_upgrade_command() {
  # shellcheck disable=SC2154
  package="${args[package]}"
  ref="${args[--ref]}"
  handler="upgrade_$package"

  if function_exists "$handler"; then
    $handler "$ref"
  else
    error "Invalid package: $package"
    exit 1
  fi

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dotbot_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action=${1:-}

  case $action in
    -*) ;;

    sync)
      action="sync"
      shift
      dotbot_sync_parse_requirements "$@"
      shift $#
      ;;

    upgrade)
      action="upgrade"
      shift
      dotbot_upgrade_parse_requirements "$@"
      shift $#
      ;;

    "")
      dotbot_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

dotbot_sync_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotbot_sync_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  if command -v awk > /dev/null 2>&1; then
    deps['awk']="$(command -v awk | head -n1)"
  else
    printf "missing dependency: awk\n" >&2
    printf "%s\n" "install with $(green brew install awk)" >&2
    exit 1
  fi

  if command -v brew > /dev/null 2>&1; then
    deps['brew']="$(command -v brew | head -n1)"
  else
    printf "missing dependency: brew\n" >&2
    printf "%s\n" "visit $(blue_underlined https://brew.sh/) to install" >&2
    exit 1
  fi

  if command -v cargo > /dev/null 2>&1; then
    deps['cargo']="$(command -v cargo | head -n1)"
  else
    printf "missing dependency: cargo\n" >&2
    printf "%s\n" "visit $(blue_underlined https://rustup.rs/) to install" >&2
    exit 1
  fi

  if command -v jq > /dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "install with $(green brew install jq)" >&2
    exit 1
  fi

  if command -v npm > /dev/null 2>&1; then
    deps['npm']="$(command -v npm | head -n1)"
  else
    printf "missing dependency: npm\n" >&2
    printf "%s\n" "install with $(green brew install node)" >&2
    exit 1
  fi

  if command -v pipx > /dev/null 2>&1; then
    deps['pipx']="$(command -v pipx | head -n1)"
  else
    printf "missing dependency: pipx\n" >&2
    printf "%s\n" "install with $(green python -m pip install pipx)" >&2
    exit 1
  fi

  action="sync"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --brew | -b)

        args['--brew']=1
        shift
        ;;

      --node | -n)

        args['--node']=1
        shift
        ;;

      --python | -p)

        args['--python']=1
        shift
        ;;

      --cargo | -c)

        args['--cargo']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

dotbot_upgrade_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dotbot_upgrade_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="upgrade"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --ref | -r)

        if [[ -n ${2+x} ]]; then
          args['--ref']="$2"
          shift
          shift
        else
          printf "%s\n" "--ref requires an argument: --ref, -r REF" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['package']+x} ]]; then
          args['package']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['package']:-} ]] || args['package']="all"

  if [[ -n ${args['package']:-} ]] && [[ ! ${args['package']:-} =~ ^(all|brew|cargo|neovim|nnn|npm|plugins|python)$ ]]; then
    printf "%s\n" "package must be one of: all, brew, cargo, neovim, nnn, npm, plugins, python" >&2
    exit 1
  fi

}

initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # shellcheck disable=SC2034
  #
  # Code here runs inside the `initialize()` function
  #
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  #
  #     > DOTFILES_DIRECTORY="${HOME}/dotfiles"
  #
  # Feel free to empty (but not delete) this file.

  case "$(uname)" in
    Darwin) ;;
    *)
      error "'dotbot' command is only supported on a mac machine"
      exit 1
      ;;
  esac

  HOMEBREW_PREFIX="${HOMEBREW_PREFIX:-$(brew --prefix)}"

  # Common directories
  DOTFILES_DIRECTORY="${HOME}/dotfiles"
  NEOVIM_DIRECTORY="${HOME}/contributing/neovim"
  NEOVIM_INSTALL_DIRECTORY="${HOME}/neovim"
  NNN_DIRECTORY="${HOME}/git/nnn"

  # Packages file
  PACKAGE_DIR="${DOTFILES_DIRECTORY}/src/package"
  HOMEBREW_BUNDLE_FILE="${PACKAGE_DIR}/Brewfile"
  PYTHON_GLOBAL_REQUIREMENTS="${PACKAGE_DIR}/requirements.txt"
  NPM_GLOBAL_PACKAGES="${PACKAGE_DIR}/node_modules.txt"
  CARGO_GLOBAL_PACKAGES="${PACKAGE_DIR}/cargo_packages.txt"

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "sync") dotbot_sync_command ;;
    "upgrade") dotbot_upgrade_command ;;
  esac
}

initialize
run "$@"

#!/usr/bin/env bash
# This script was generated by bashly 0.7.7 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :script.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dot_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot - Personal tool for managing dotfiles and packages\n"
    echo

  else
    printf "dot - Personal tool for managing dotfiles and packages\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dot [command]\n"
  printf "  dot [command] --help | -h\n"
  printf "  dot --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  mac       update macOS related stuff"
  echo "  link      symlink dotfiles after backing up the existing ones"
  echo "  shell     setup the default shell for the current user"
  echo "  setup     setup a new mac machine the way I like it"
  echo "  sync      sync lib files with global package list"
  echo "  upgrade   upgrade packages"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dot_mac_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot mac - update macOS related stuff\n"
    echo

  else
    printf "dot mac - update macOS related stuff\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dot mac [options]\n"
  printf "  dot mac --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --dock, -d"
    printf "    update macOS dock applications\n"
    echo

    # :flag.usage
    echo "  --settings, -s"
    printf "    update macOS settings\n"
    echo

  fi
}

# :command.usage
dot_link_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot link - symlink dotfiles after backing up the existing ones\n"
    echo

  else
    printf "dot link - symlink dotfiles after backing up the existing ones\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dot link [options]\n"
  printf "  dot link --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    skip backup for the existing dotfiles\n"
    echo

  fi
}

# :command.usage
dot_shell_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot shell\n"
    echo

    printf "  setup the default shell for the current user\n  \n  Default shell path: \"$DEFAULT_SHELL_PATH\"\n"
    echo

  else
    printf "dot shell - setup the default shell for the current user\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dot shell\n"
  printf "  dot shell --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dot_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot setup - setup a new mac machine the way I like it\n"
    echo

  else
    printf "dot setup - setup a new mac machine the way I like it\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dot setup\n"
  printf "  dot setup --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dot_sync_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot sync - sync lib files with global package list\n"
    echo

  else
    printf "dot sync - sync lib files with global package list\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dot sync [options]\n"
  printf "  dot sync --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --brew, -b"
    printf "    sync only homebrew packages\n    File: $HOMEBREW_BUNDLE_FILE\n"
    echo

    # :flag.usage
    echo "  --node, -n"
    printf "    sync only node packages\n    File: $NPM_GLOBAL_PACKAGES\n"
    echo

    # :flag.usage
    echo "  --python, -p"
    printf "    sync only Python packages\n    File: $PYTHON_GLOBAL_REQUIREMENTS\n"
    echo

    # :flag.usage
    echo "  --cargo, -c"
    printf "    sync only Cargo packages\n    File: $CARGO_GLOBAL_PACKAGES\n"
    echo

  fi
}

# :command.usage
dot_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot upgrade - upgrade packages\n"
    echo

  else
    printf "dot upgrade - upgrade packages\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dot upgrade [PACKAGE] [options]\n"
  printf "  dot upgrade --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --ref, -r REF"
    printf "    Upgrade to a specific ref (commit/branch/tag). This flag is applicable only\n    when 'PACKAGE' is:\n      - neovim\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    package to upgrade\n"
    printf "    Allowed: all, brew, cargo, mac, neovim, nnn, npm, plugins, python\n"
    printf "    Default: all\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# :src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
#
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# :src/lib/log.sh
# Helper functions to log to stdout with colors and indicators.

header() {
  bold "==> $1"
}

error() {
  red_bold "[✗] $1"
}

warning() {
  yellow_bold "[!] $1"
}

# :src/lib/setup.sh
declare -a PY_NEOVIM_PACKAGES=(
  "pynvim"
  "debugpy"
)

declare -A SYMLINKS=(
  [".editorconfig"]=".editorconfig"
  ["bash/bash_profile"]=".bash_profile"
  ["bash/bashrc"]=".bashrc"
  ["bat"]=".config/bat"
  ["bottom"]="Library/Application Support/bottom"
  ["bpytop"]=".config/bpytop"
  ["gh/config.yml"]=".config/gh/config.yml"
  ["git/config"]=".gitconfig"
  ["git/message"]=".gitmessage"
  ["glow"]="Library/Preferences/glow"
  ["gpg/gpg-agent.conf"]=".gnupg/gpg-agent.conf"
  ["gpg/gpg.conf"]=".gnupg/gpg.conf"
  ["grip"]=".config/grip"
  ["hammerspoon"]=".hammerspoon"
  ["himalaya"]=".config/himalaya"
  ["htop"]=".config/htop"
  ["ignore"]=".ignore"
  ["inputrc"]=".inputrc"
  ["ipython/ipython_config.py"]=".ipython/profile_default/ipython_config.py"
  ["ipython/startup"]=".ipython/profile_default/startup"
  ["jupyter/jupyter_lab_config.py"]=".jupyter/jupyter_lab_config.py"
  ["jupyter/jupyter_notebook_config.py"]=".jupyter/jupyter_notebook_config.py"
  ["jupyter/lab/user-settings"]=".jupyter/lab/user-settings"
  ["karabiner"]=".config/karabiner"
  ["kitty"]=".config/kitty"
  ["nvim"]=".config/nvim"
  ["pip"]=".config/pip"
  ["ssh/config"]=".ssh/config"
  ["starship.toml"]=".config/starship.toml"
  ["tmux/tmux.conf"]=".tmux.conf"
  ["vim"]=".vim"
  ["vim/vimrc"]=".vimrc"
  ["youtube-dl"]=".config/youtube-dl"
  ["zsh/zshenv"]=".zshenv"
  ["zsh/zshrc"]=".zshrc"
)

download_dotfiles() { # {{{1
  header "Downloading the dotfiles..."
  mkdir -p "${DOTFILES_DIRECTORY}"
  curl -fsSLo ~/dotfiles.tar.gz https://github.com/dhruvmanila/dotfiles/tarball/master

  header "Extracting the dotfiles..."
  tar -zxf "${HOME}/dotfiles.tar.gz" --strip-components 1 -C "${DOTFILES_DIRECTORY}"
  rm -rf ~/dotfiles.tar.gz
}

install_cargo_packages() { # {{{1
  header "Installing global cargo packages from ${CARGO_GLOBAL_PACKAGES}..."
  while IFS= read -r package; do
    cargo install "$package"
  done < "${CARGO_GLOBAL_PACKAGES}"
}

install_homebrew() { # {{{1
  header "Installing Homebrew..."
  set +e
  if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"; then
    error "Failure occured during Homebrew installation"
    # https://github.com/Homebrew/brew/pull/9383
    core_location="/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core"

    header "Checking if homebrew-core is a shallow clone..."
    if [[ -f "${core_location}/.git/shallow" ]]; then
      header "Fetching everything from homebrew/homebrew-core (this may take a while)..."

      # This `git` is from the xcode command-line tools. By default, we will
      # be using the brew installed `git` to keep up-to date.
      git -C $core_location fetch --unshallow
    else
      error "Unknown error while installing homebrew, exiting..."
      exit 1
    fi
  fi
  set -e
}

install_homebrew_packages() { # {{{1
  header "Installing homebrew bundle tap..."
  brew tap homebrew/bundle

  header "Installing packages from Brewfile..."
  #  prints output from commands as they are run ┐
  #                                              │
  HOMEBREW_NO_AUTO_UPDATE=1 brew bundle install -v --no-lock --file "$HOMEBREW_BUNDLE_FILE"
  #                                                  │
  #         don't output a `Brewfile.lock.json` file ┘

  header "Cleaning up..."
  brew cleanup
}

install_npm_global_packages() { # {{{1
  header "Installing global npm packages from ${NPM_GLOBAL_PACKAGES}..."
  while IFS= read -r package; do
    npm --global install "$package"
  done < "${NPM_GLOBAL_PACKAGES}"
}

install_python() { # {{{1
  # Setup the mentioned Python versions in from the constant $PYTHON_VERSIONS.
  # The first element is made the global Python version.
  #
  # If the version is already installed, it will be skipped. `pip` will be
  # upgraded for every mentioned version.
  for python_version in "${PYTHON_VERSIONS[@]}"; do
    if ! pyenv versions | grep -q "${python_version}"; then
      header "Installing Python ${python_version}..."
      pyenv install "${python_version}"
    else
      header "Python $python_version is already installed."
    fi
    header "Upgrading pip for Python ${python_version}..."
    "$(pyenv root)/versions/${python_version}/bin/pip" install --upgrade pip
  done

  pyenv_global_python="${PYTHON_VERSIONS[0]}"
  header "Making ${pyenv_global_python} as the global Python version..."
  pyenv global "${pyenv_global_python}"

  header "Initiating pyenv..."
  eval "$(pyenv init -)"
  eval "$(pyenv init --path)"
}

install_python_global_packages() { # {{{1
  header "Installing pipx to manage global packages..."
  python -m pip install pipx
  pyenv rehash

  header "Installing global Python packages from ${PYTHON_GLOBAL_REQUIREMENTS}..."
  while IFS= read -r package; do
    if [[ "$package" == "jupyter" ]]; then
      # 'jupyter' is a metapackage used for installation of all packages related
      # to the ecosystem.
      pipx install --include-deps "$package"

      # These packages needs to be injected in the same environment.
      pipx inject --include-apps "$package" jupyterlab
      pipx inject --include-apps "$package" jupytext
    else
      pipx install "$package"
    fi
  done < "${PYTHON_GLOBAL_REQUIREMENTS}"
}

install_xcode_command_line_tools() { # {{{1
  header "Installing xcode command line tools..."
  xcode-select --install
  # wait until the tools are installed...
  until xcode-select -p &> /dev/null; do
    sleep 5
  done
}

setup_aws() { # {{{1
  # This is the recommended way of installing the tool.
  # https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html#cliv2-mac-install-cmd
  curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"

  # This requires root permission to create symlinks between `path/to/aws-cli/*`
  # and `/usr/local/bin/*` where '*' indicates the necessary executables.
  sudo installer -pkg AWSCLIV2.pkg -target /

  rm AWSCLIV2.pkg
}

setup_dotfiles_git_repository() { # {{{1
  header "Initializing Git repository..."
  set -x
  git init
  git remote add origin https://github.com/dhruvmanila/dotfiles
  git fetch --all
  git reset --hard FETCH_HEAD
  git branch --set-upstream-to origin/master master
  set +x
}

setup_github_ssh() { # {{{1
  # NOTE: This function should be called after symlinking the dotfiles
  ssh -T git@github.com &> /dev/null
  if [[ $? -eq 1 ]]; then
    return
  fi

  local ssh_algorithm="ed25519"
  local ssh_filename="github"

  header "Generating SSH keys..."
  ask "Please provide an email address"
  ssh-keygen -f "${HOME}/.ssh/${ssh_filename}" -t "$ssh_algorithm" -C "$REPLY"

  # shellcheck disable=SC1090
  source "$(ssh-agent)"
  header "Adding SSH key to the ssh-agent..."
  ssh-add -K "${HOME}/.ssh/${ssh_filename}"

  header "Copied public SSH key to clipboard. Please add it to GitHub.com..."
  pbcopy < "${HOME}/.ssh/${ssh_filename}.pub"
  open "https://github.com/settings/ssh"
  for i in {1..6}; do
    ssh -T git@github.com &> /dev/null
    if [[ $? -eq 1 ]]; then
      header "Authentication successful."
      break
    else
      if [[ i -eq 6 ]]; then
        error "Exceeded max retries. Authenticate using 'ssh -T git@github.com' command."
        break
      fi
      error "Failed to authenticate. Retrying in 5 seconds..."
    fi
    sleep 5
  done
}

setup_neovim_nightly() { # {{{1
  header "Setting up Neovim nightly..."
  git clone --depth=1 git@github.com:dhruvmanila/neovim.git "$NEOVIM_DIRECTORY"
  (
    cd "$NEOVIM_DIRECTORY" || exit 1
    git checkout master
    git remote add upstream git@github.com:neovim/neovim.git
    build_neovim
  )
  header "Setting up Neovim Python environment..."
  (
    cd ~/.neovim || exit 1
    python3 -m venv --prompt pynvim .venv
    source venv/bin/activate
    pip3 install "${PY_NEOVIM_PACKAGES[*]}"
    deactivate
  )
}

setup_nnn() { # {{{1
  header "Setting up nnn..."
  git clone git@github.com:jarun/nnn.git "$NNN_DIRECTORY"
  (
    cd "$NNN_DIRECTORY" || exit 1
    git fetch origin --tags --force
    git checkout "$(git describe --abbrev=0)"
    build_nnn
  )
}

setup_symlinks() { # {{{1
  # What does this file do? {{{
  #
  #   > Immediately after logging a user in, login displays the system copyright
  #   > notice, the date and time the user last logged in, the message of the day
  #   > as well as other information. If the file .hushlogin exists in the user's
  #   > home directory, all of these messages are suppressed.
  #
  # Source: `man login`
  # }}}
  if [[ ! -f "${HOME}/.hushlogin" ]]; then
    touch ~/.hushlogin
  fi

  # Create the necessary symbolic links between the `dotfiles` and `HOME` directory.
  header "Creating the necessary symlinks..."

  #                ┌ list associative array keys
  #                │
  for source in "${!SYMLINKS[@]}"; do
    link "$source" "${SYMLINKS[$source]}"
  done
}

setup_tmux_plugins() { # {{{1
  header "Installing tmux plugin manager..."
  git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm

  header "Installing tmux plugins..."
  ~/.tmux/plugins/tpm/bin/install_plugins
}

update_macos_settings() { # {{{1
  header "Updating macOS settings..."
  bash "${DOTFILES_DIRECTORY}/src/mac/osxdefaults"
}

update_macos_dock() { # {{{1
  header "Updating macOS dock applications..."
  dockutil --remove all --no-restart
  for app in "${MACOS_DOCK_APPLICATIONS[@]}"; do
    echo "    Adding '$app'..."
    dockutil --add "$app" --section apps --no-restart
  done

  echo "    Adding '${HOME}/Downloads'..."
  dockutil \
    --add "${HOME}/Downloads" \
    --view grid \
    --display folder \
    --sort dateadded \
    --section others \
    --no-restart

  header "Restarting the dock..."
  killall Dock &> /dev/null
}

# }}}1

# :src/lib/upgrade.sh
upgrade_all() { # {{{1
  upgrade_brew
  upgrade_plugins
  upgrade_npm
  upgrade_python
  upgrade_cargo
  upgrade_neovim "$@"
  upgrade_nnn
  upgrade_mac
}

upgrade_brew() { # {{{1
  header "Updating homebrew..."
  brew update

  header "Upgrading homebrew packages..."
  brew upgrade

  header "Upgrading outdated casks..."
  brew upgrade --cask --greedy

  # Remove all cache files older than one day
  header "Cleaning up..."
  brew cleanup --prune 1
}

upgrade_cargo() { # {{{1
  header "Upgrading global cargo packages..."
  while IFS= read -r package; do
    # The `install` command updates the package if there is a newer version.
    cargo install "$package"
  done < "${CARGO_GLOBAL_PACKAGES}"
}

upgrade_mac() { # {{{1
  header "Upgrading macOS applications..."
  mas upgrade

  header "Finding available software..."
  output="$(softwareupdate --list 2>&1)"
  if (($? > 0)) && [[ "$output" = *"No new software available"* ]]; then
    echo "No new software available."
  else
    echo "$output"
    seek_confirmation "A system update is available. Do you wish to install it?"
    if is_confirmed; then
      softwareupdate --install --all
    fi
  fi
}

upgrade_neovim() { # {{{1
  header "Upgrading Neovim to ${1:-"the latest commit on master"}..."
  (
    cd "$NEOVIM_DIRECTORY" || exit 1
    curr_hash=$(git rev-parse HEAD)

    # Pull the latest changes
    git checkout master
    git pull upstream master
    git push origin master
    git fetch upstream --tags --force
    if [[ -n $1 ]]; then
      git checkout "$1"
    fi

    new_hash=$(git rev-parse HEAD)
    if [[ "$curr_hash" == "$new_hash" ]]; then
      seek_confirmation "Neovim seems to be already up to date"
      if ! is_confirmed; then
        return
      fi
    fi

    build_neovim
  )
}

upgrade_nnn() { # {{{1
  header "Upgrading nnn to the latest version..."
  (
    cd "$NNN_DIRECTORY" || exit 1
    current_tag="$(git describe --abbrev=0)"
    git checkout master
    git pull origin master
    git fetch origin --tags --force
    latest_tag="$(git describe --abbrev=0)"
    if [[ "$current_tag" == "$latest_tag" ]]; then
      echo "==> nnn is already up to date to $latest_tag"
      return
    fi
    git checkout "$latest_tag"
    build_nnn
  )
}

upgrade_npm() { # {{{1
  header "Upgrading npm and packages..."
  npm --global install npm@latest
  npm --global upgrade
}

upgrade_plugins() { # {{{1
  # Not quiting vim/neovim to check what's new
  header "Upgrading vim plugins..."
  vim +PlugUpgrade +PlugClean +PlugUpdate

  header "Upgrading neovim plugins..."
  nvim +PackerSync

  header "Cleaning and updating tmux plugins..."
  ~/.tmux/plugins/tpm/bin/clean_plugins
  ~/.tmux/plugins/tpm/bin/update_plugins all
}

upgrade_python() { # {{{1
  header "Upgrading pip for all pyenv Python versions..."
  for python_exec in "$PYENV_ROOT"/versions/*/bin/python; do
    $python_exec -m pip install --upgrade pip
  done

  header "Upgrading pipx..."
  "$PYENV_ROOT/bin/python" -m pip install --upgrade pipx

  header "Upgrading all Python global packages..."
  pipx upgrade-all --include-injected
}

# }}}1

# :src/lib/utils.sh
ask() { # {{{1
  yellow_bold "[?] $1"
  read -r -p "$(bold "> ")"
}

build_neovim() { # {{{1
  make distclean
  make \
    CMAKE_BUILD_TYPE="${NEOVIM_BUILD_TYPE:-"Release"}" \
    CMAKE_EXTRA_FLAGS="-DCMAKE_INSTALL_PREFIX=$NEOVIM_INSTALL_DIRECTORY"
  make install
}

build_nnn() { # {{{1
  make uninstall
  make O_NERD=1 install
}

command_exists() { # {{{1
  command -v "$1" &> /dev/null
}

function_exists() { # {{{1
  [[ "$(type -t "$1")" == "function" ]]
}

get_jupyter_app_dir() { # {{{1
  printf "%s" "$(jupyter lab path \
    | awk -F ':[ ]+' '{ if($1 == "Application directory") {print $2} }')"
}

is_confirmed() { # {{{1
  [[ "$REPLY" =~ ^[Yy]$ ]]
}

is_git_repo() { # {{{1
  git rev-parse --is-inside-work-tree &> /dev/null
}

link() { # {{{1
  local source_file="${DOTFILES_DIRECTORY}/config/${1}"
  local target_file="${HOME}/${2}"
  if ! [[ -e "$target_file" ]]; then
    echo "==> $target_file -> $source_file"
    ln -fs "$source_file" "$target_file"
  fi
}

seek_confirmation() { # {{{1
  warning "$1"
  read -r -p "$(bold "[y/n] ")" -n 1
  printf "\n"
}

setup_required_directories() { # {{{1
  for directory in "${REQUIRED_DIRECTORIES[@]}"; do
    if ! [[ -d $directory ]]; then
      mkdir -p "$directory"
      if [[ -z $1 ]]; then
        echo "==> Created $directory"
      fi
    fi
  done
}

# }}}1

# :command.command_functions
# :command.function
dot_mac_command() {
  # :src/mac_command.sh
  # shellcheck disable=SC2154
  dock=${args[--dock]}
  settings=${args[--settings]}

  if [[ $dock ]]; then
    update_macos_dock
  fi

  if [[ $settings ]]; then
    seek_confirmation "This will override your macOS settings"
    if is_confirmed; then
      update_macos_settings
    fi
  fi
}

# :command.function
dot_link_command() {
  # :src/link_command.sh
  # shellcheck disable=SC2154
  force=${args[--force]}

  if ! [[ $force ]]; then
    declare -i count=0
    backup_dir="${HOME}/dotfiles_$(date +"%Y_%m_%dT%H_%M_%S").backup"
    mkdir "$backup_dir"

    for location in "${BACKUP_DOTFILES[@]}"; do
      if [[ -f $location || -d $location ]]; then
        cp -R "$location" "$backup_dir"
        ((count += 1))
      fi
    done

    if ((count > 0)); then
      header "Created backup in ${backup_dir}"
    else
      header "Skipped backup as there are no dotfiles"
      rm -rf "$backup_dir"
    fi
  fi

  setup_symlinks
}

# :command.function
dot_shell_command() {
  # :src/shell_command.sh
  # Setup the default shell as mentioned in the DEFAULT_SHELL_PATH global
  # variable. This will be skipped if the shell is already the default one.

  # https://stackoverflow.com/a/41553295
  if dscl . -read ~/ UserShell | grep "$DEFAULT_SHELL_PATH" &> /dev/null; then
    header "'$DEFAULT_SHELL_PATH' is already the default shell."
    return
  fi

  if ! grep -F -q "${DEFAULT_SHELL_PATH}" /etc/shells; then
    header "Adding '$DEFAULT_SHELL_PATH' to /etc/shells..."
    echo "${DEFAULT_SHELL_PATH}" | sudo tee -a /etc/shells
  fi

  header "Switching to '${DEFAULT_SHELL_PATH}' as the default shell..."
  chsh -s "${DEFAULT_SHELL_PATH}"
}

# :command.function
dot_setup_command() {
  # :src/setup_command.sh
  seek_confirmation "'setup' command should only be invoked on a fresh setup"
  if ! is_confirmed; then
    exit
  fi

  setup_required_directories

  if ! [[ -d "$DOTFILES_DIRECTORY" ]]; then
    download_dotfiles
  fi

  header "Changing directory to $DOTFILES_DIRECTORY..."
  cd "$DOTFILES_DIRECTORY" || exit 1

  if ! xcode-select -p &> /dev/null; then
    install_xcode_command_line_tools
  fi

  if ! command_exists 'brew'; then
    install_homebrew
  fi
  install_homebrew_packages

  if ! is_git_repo; then
    setup_dotfiles_git_repository
  fi

  install_python
  install_python_global_packages
  install_global_npm_packages
  install_cargo_packages

  setup_aws

  setup_neovim_nightly

  # No backup as this is a fresh setup
  setup_symlinks

  setup_tmux_plugins
  setup_github_ssh

  update_macos_settings
  update_macos_dock
}

# :command.function
dot_sync_command() {
  # :src/sync_command.sh
  # shellcheck disable=SC2154
  sync_brew=${args[--brew]}
  sync_node=${args[--node]}
  sync_python=${args[--python]}
  sync_cargo=${args[--cargo]}

  # If there are no arguments, then the default behavior is to sync all files.
  if [[ -z ${args[*]} ]]; then
    sync_all=1
  fi

  if [[ $sync_all || $sync_brew ]]; then
    header "Syncing Brewfile with the currently installed packages..."
    HOMEBREW_NO_AUTO_UPDATE=1 brew bundle dump -f --describe
  fi

  if [[ $sync_all || $sync_python ]]; then
    header "Syncing requirements.txt with the global Python packages..."
    pipx list --json \
      | jq --raw-output '.venvs | keys | join("\n")' \
        > "${PYTHON_GLOBAL_REQUIREMENTS}"
  fi

  if [[ $sync_all || $sync_node ]]; then
    header "Syncing node_modules.txt with the global Node packages..."
    npm --global --json list \
      | jq --raw-output '.dependencies | del(."instant-markdown-d") | keys | join("\n")' \
        > "${NPM_GLOBAL_PACKAGES}"
  fi

  if [[ $sync_all || $sync_cargo ]]; then
    header "Syncing cargo_packages.txt with the global Cargo packages..."
    cargo install --list \
      | awk -F ' ' '{ if(NR % 2 == 1) {print $1} }' \
        > "${CARGO_GLOBAL_PACKAGES}"
  fi
}

# :command.function
dot_upgrade_command() {
  # :src/upgrade_command.sh
  # shellcheck disable=SC2154
  package="${args[package]}"
  ref="${args[--ref]}"
  handler="upgrade_$package"

  if function_exists "$handler"; then
    $handler "$ref"
  else
    error "Invalid package: $package"
    exit 1
  fi
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    \
      mac)
      action="mac"
      shift
      dot_mac_parse_requirements "$@"
      shift $#
      ;;

    link)
      action="link"
      shift
      dot_link_parse_requirements "$@"
      shift $#
      ;;

    shell)
      action="shell"
      shift
      dot_shell_parse_requirements "$@"
      shift $#
      ;;

    setup)
      action="setup"
      shift
      dot_setup_parse_requirements "$@"
      shift $#
      ;;

    sync)
      action="sync"
      shift
      dot_sync_parse_requirements "$@"
      shift $#
      ;;

    upgrade)
      action="upgrade"
      shift
      dot_upgrade_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    *)
      dot_usage
      exit 1
      ;;

  esac
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dot_mac_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_mac_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="mac"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --dock | -d)
        # :flag.conflicts
        args[--dock]=1
        shift
        ;;

      # :flag.case
      --settings | -s)
        # :flag.conflicts
        args[--settings]=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dot_link_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_link_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="link"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)
        # :flag.conflicts
        args[--force]=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dot_shell_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_shell_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="shell"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dot_setup_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_setup_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="setup"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dot_sync_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_sync_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="sync"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --brew | -b)
        # :flag.conflicts
        args[--brew]=1
        shift
        ;;

      # :flag.case
      --node | -n)
        # :flag.conflicts
        args[--node]=1
        shift
        ;;

      # :flag.case
      --python | -p)
        # :flag.conflicts
        args[--python]=1
        shift
        ;;

      # :flag.case
      --cargo | -c)
        # :flag.conflicts
        args[--cargo]=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
  # :command.user_filter
}

# :command.parse_requirements
dot_upgrade_parse_requirements() {
  # :command.fixed_flag_filter
  case "${1:-}" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_upgrade_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="upgrade"
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ref | -r)
        # :flag.conflicts
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          args[--ref]="$2"
          shift
          shift
        else
          printf "%s\n" "--ref requires an argument: --ref, -r REF"
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        if [[ -z ${args[package]+x} ]]; then
          # :argument.validations
          args[package]=$1
          shift
        else
          printf "invalid argument: %s\n" "$key"
          exit 1
        fi
        ;;

    esac
  done
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[package]:-} ]] || args[package]="all"
  # :command.whitelist_filter
  if [[ ! ${args[package]} =~ ^(all|brew|cargo|mac|neovim|nnn|npm|plugins|python)$ ]]; then
    printf "%s\n" "package must be one of: all, brew, cargo, mac, neovim, nnn, npm, plugins, python"
    exit 1
  fi
  # :command.user_filter
}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # :src/initialize.sh
  # shellcheck disable=SC2034
  #
  # Code here runs inside the `initialize()` function
  #
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  #
  #     > DOTFILES_DIRECTORY="${HOME}/dotfiles"
  #
  # Feel free to empty (but not delete) this file.

  case "$(uname)" in
    Darwin) ;;
    *)
      error "'dot' command is only supported on a mac machine"
      exit 1
      ;;
  esac

  HOMEBREW_PREFIX="${HOMEBREW_PREFIX:-$(brew --prefix)}"

  # Default shell path. This can be set using `dot shell`.
  DEFAULT_SHELL_PATH="${HOMEBREW_PREFIX}/bin/zsh"

  # Common directories
  DOTFILES_DIRECTORY="${HOME}/dotfiles"
  NEOVIM_DIRECTORY="${HOME}/contributing/neovim"
  NEOVIM_INSTALL_DIRECTORY="${HOME}/neovim"
  NNN_DIRECTORY="${HOME}/git/nnn"

  # Python versions to be installed on the system.
  # First version will be the global one
  PYTHON_VERSIONS=(
    "3.10.2"
    "3.9.10"
  )

  # Packages file
  PACKAGE_DIR="${DOTFILES_DIRECTORY}/src/package"
  HOMEBREW_BUNDLE_FILE="${PACKAGE_DIR}/Brewfile"
  PYTHON_GLOBAL_REQUIREMENTS="${PACKAGE_DIR}/requirements.txt"
  NPM_GLOBAL_PACKAGES="${PACKAGE_DIR}/node_modules.txt"
  CARGO_GLOBAL_PACKAGES="${PACKAGE_DIR}/cargo_packages.txt"

  # On initialization of the script, if these directories does not exist, then
  # they will be created.
  REQUIRED_DIRECTORIES=(
    ~/.config
    ~/.gnupg
    ~/.ssh
    ~/contributing
    ~/git
    ~/neovim
    ~/playground
    ~/projects
    ~/work
  )

  # These files/directories will be backed up before symlinking, if they exists.
  # This step can be skipped if `-f/--force` flag is passed to the `link` command.
  BACKUP_DOTFILES=(
    ~/.bash_profile
    ~/.bashrc
    ~/.config
    ~/.gitconfig
    ~/.inputrc
    ~/.tmux.conf
    ~/.vim
  )

  # MacOS dock applications
  # Keep everything quoted due to spaces. Order: left to right
  MACOS_DOCK_APPLICATIONS=(
    "/Applications/Safari.app"
    "/Applications/Brave Browser.app"
    "/Applications/kitty.app"
    "/Applications/Docker.app/Contents/MacOS/Docker Desktop.app"
    "/Applications/pgAdmin 4.app"
    "/System/Applications/Notes.app"
    "/System/Applications/Music.app"
    "/System/Applications/Books.app"
    "/Applications/Microsoft Excel.app"
    "/Applications/Microsoft Teams.app"
    "/Applications/Microsoft Outlook.app"
    "/Applications/Slack.app"
    "/Applications/Azure VPN Client.app"
  )

  setup_required_directories silent
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "mac" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dot_mac_usage
    else
      dot_mac_command
    fi

  elif [[ $action == "link" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dot_link_usage
    else
      dot_link_command
    fi

  elif [[ $action == "shell" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dot_shell_usage
    else
      dot_shell_command
    fi

  elif [[ $action == "setup" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dot_setup_usage
    else
      dot_setup_command
    fi

  elif [[ $action == "sync" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dot_sync_usage
    else
      dot_sync_command
    fi

  elif [[ $action == "upgrade" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      dot_upgrade_usage
    else
      dot_upgrade_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"

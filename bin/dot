#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dot_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot - Personal tool for managing dotfiles and packages\n"
    echo
  else
    printf "dot - Personal tool for managing dotfiles and packages\n"
    echo
  fi

  printf "Usage:\n"
  printf "  dot [command]\n"
  printf "  dot [command] --help | -h\n"
  printf "  dot --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  mac       update macOS related stuff"
  echo "  link      symlink dotfiles after backing up the existing ones"
  echo "  setup     setup a new mac machine the way I like it"
  echo "  sync      sync lib files with global package list"
  echo "  upgrade   upgrade packages"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dot_mac_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot mac - update macOS related stuff\n"
    echo
  else
    printf "dot mac - update macOS related stuff\n"
    echo
  fi

  printf "Usage:\n"
  printf "  dot mac [options]\n"
  printf "  dot mac --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --dock, -d"
    printf "    update macOS dock applications\n"
    echo

    # :flag.usage
    echo "  --settings, -s"
    printf "    update macOS settings\n"
    echo

  fi
}

# :command.usage
dot_link_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot link - symlink dotfiles after backing up the existing ones\n"
    echo
  else
    printf "dot link - symlink dotfiles after backing up the existing ones\n"
    echo
  fi

  printf "Usage:\n"
  printf "  dot link [options]\n"
  printf "  dot link --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --force, -f"
    printf "    skip backup for the existing dotfiles\n"
    echo

  fi
}

# :command.usage
dot_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot setup - setup a new mac machine the way I like it\n"
    echo
  else
    printf "dot setup - setup a new mac machine the way I like it\n"
    echo
  fi

  printf "Usage:\n"
  printf "  dot setup\n"
  printf "  dot setup --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dot_sync_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot sync - sync lib files with global package list\n"
    echo
  else
    printf "dot sync - sync lib files with global package list\n"
    echo
  fi

  printf "Usage:\n"
  printf "  dot sync [options]\n"
  printf "  dot sync --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --brew, -b"
    printf "    sync only homebrew packages\n    File: $HOMEBREW_BUNDLE_FILE\n"
    echo

    # :flag.usage
    echo "  --node, -n"
    printf "    sync only node packages\n    File: $NPM_GLOBAL_PACKAGES\n"
    echo

    # :flag.usage
    echo "  --python, -p"
    printf "    sync only Python packages\n    File: $PYTHON_GLOBAL_REQUIREMENTS\n"
    echo

  fi
}

# :command.usage
dot_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot upgrade - upgrade packages\n"
    echo
  else
    printf "dot upgrade - upgrade packages\n"
    echo
  fi

  printf "Usage:\n"
  printf "  dot upgrade [PACKAGE] [options]\n"
  printf "  dot upgrade --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --ref, -r REF"
    printf "    Upgrade to a specific ref (commit/branch/tag). This flag is applicable only\n    when 'PACKAGE' is:\n      - neovim\n      - lua_lsp\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  PACKAGE"
    printf "    package to upgrade\n"
    printf "    Allowed: all, brew, lua_lsp, neovim, packages, plugins\n"
    printf "    Default: all\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# :src/lib/colors.sh
# ---
# Color functions
# This file is a part of Bashly standard library
#
# Usage:
# Use any of the functions below to color or format a portion of a string.
#
#   echo "before $(red this is red) after"
#   echo "before $(green_bold this is green_bold) after"
#
# ---

red() { printf "\e[31m%b\e[0m\n" "$*"; }
green() { printf "\e[32m%b\e[0m\n" "$*"; }
yellow() { printf "\e[33m%b\e[0m\n" "$*"; }
blue() { printf "\e[34m%b\e[0m\n" "$*"; }
magenta() { printf "\e[35m%b\e[0m\n" "$*"; }
cyan() { printf "\e[36m%b\e[0m\n" "$*"; }
bold() { printf "\e[1m%b\e[0m\n" "$*"; }
underlined() { printf "\e[4m%b\e[0m\n" "$*"; }
red_bold() { printf "\e[1;31m%b\e[0m\n" "$*"; }
green_bold() { printf "\e[1;32m%b\e[0m\n" "$*"; }
yellow_bold() { printf "\e[1;33m%b\e[0m\n" "$*"; }
blue_bold() { printf "\e[1;34m%b\e[0m\n" "$*"; }
magenta_bold() { printf "\e[1;35m%b\e[0m\n" "$*"; }
cyan_bold() { printf "\e[1;36m%b\e[0m\n" "$*"; }
red_underlined() { printf "\e[4;31m%b\e[0m\n" "$*"; }
green_underlined() { printf "\e[4;32m%b\e[0m\n" "$*"; }
yellow_underlined() { printf "\e[4;33m%b\e[0m\n" "$*"; }
blue_underlined() { printf "\e[4;34m%b\e[0m\n" "$*"; }
magenta_underlined() { printf "\e[4;35m%b\e[0m\n" "$*"; }
cyan_underlined() { printf "\e[4;36m%b\e[0m\n" "$*"; }

# :src/lib/log.sh
# Helper functions to log to stdout with colors and indicators.

header() {
  bold "==> $1"
}

error() {
  red_bold "[✗] $1"
}

warning() {
  yellow_bold "[!] $1"
}

# :src/lib/setup/dotfiles_git_repository.sh
setup_dotfiles_git_repository() {
  header "Initializing Git repository..."
  set -x
  git init
  git remote add origin https://github.com/dhruvmanila/dotfiles
  git fetch --all
  git reset --hard FETCH_HEAD
  git branch --set-upstream-to origin/master master
  set +x
}

# :src/lib/setup/download_dotfiles.sh
download_dotfiles() {
  header "Downloading the dotfiles..."
  mkdir -p "${DOTFILES_DIRECTORY}"
  curl -fsSLo ~/dotfiles.tar.gz https://github.com/dhruvmanila/dotfiles/tarball/master

  header "Extracting the dotfiles..."
  tar -zxf "${HOME}/dotfiles.tar.gz" --strip-components 1 -C "${DOTFILES_DIRECTORY}"
  rm -rf ~/dotfiles.tar.gz
}

# :src/lib/setup/github_ssh.sh
setup_github_ssh() {
  # NOTE: This function should be called after symlinking the dotfiles
  ssh -T git@github.com &> /dev/null
  if [[ $? -eq 1 ]]; then
    return
  fi

  local ssh_algorithm="ed25519"
  local ssh_filename="github"

  header "Generating SSH keys..."
  ask "Please provide an email address"
  ssh-keygen -f "${HOME}/.ssh/${ssh_filename}" -t "$ssh_algorithm" -C "$REPLY"

  # shellcheck disable=SC1090
  source "$(ssh-agent)"
  header "Adding SSH key to the ssh-agent..."
  ssh-add -K "${HOME}/.ssh/${ssh_filename}"

  header "Copied public SSH key to clipboard. Please add it to GitHub.com..."
  pbcopy < "${HOME}/.ssh/${ssh_filename}.pub"
  open "https://github.com/settings/ssh"
  for i in {1..6}; do
    ssh -T git@github.com &> /dev/null
    if [[ $? -eq 1 ]]; then
      header "Authentication successful."
      break
    else
      if [[ i -eq 6 ]]; then
        error "Exceeded max retries. Authenticate using 'ssh -T git@github.com' command."
        break
      fi
      error "Failed to authenticate. Retrying in 5 seconds..."
    fi
    sleep 5
  done
}

# :src/lib/setup/homebrew.sh
install_homebrew() {
  header "Installing Homebrew..."
  set +e
  if ! /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"; then
    error "Failure occured during Homebrew installation"
    # https://github.com/Homebrew/brew/pull/9383
    core_location="/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core"

    header "Checking if homebrew-core is a shallow clone..."
    if [[ -f "${core_location}/.git/shallow" ]]; then
      header "Fetching everything from homebrew/homebrew-core (this may take a while)..."

      # This `git` is from the xcode command-line tools. By default, we will
      # be using the brew installed `git` to keep up-to date.
      git -C $core_location fetch --unshallow
    else
      error "Unknown error while installing homebrew, exiting..."
      exit 1
    fi
  fi
  set -e
}

install_homebrew_packages() {
  header "Installing homebrew bundle tap..."
  brew tap homebrew/bundle

  header "Installing packages from Brewfile..."
  #  prints output from commands as they are run ┐
  #                                              │
  HOMEBREW_NO_AUTO_UPDATE=1 brew bundle install -v --no-lock --file "$HOMEBREW_BUNDLE_FILE"
  #                                                  │
  #         don't output a `Brewfile.lock.json` file ┘

  header "Cleaning up..."
  brew cleanup
}

# :src/lib/setup/lua_language_server.sh
setup_lua_language_server() {
  header "Setting up the lua language server..."
  git clone --depth=1 https://github.com/sumneko/lua-language-server.git "$LUA_LANGUAGE_SERVER_DIRECTORY"
  (
    cd "$LUA_LANGUAGE_SERVER_DIRECTORY" || exit 1
    git checkout master
    build_lua_lsp
  )
}

# :src/lib/setup/macos.sh
update_macos_settings() {
  header "Updating macOS settings..."
  bash "${DOTFILES_DIRECTORY}/mac/osxdefaults"
}

update_macos_dock() {
  header "Updating macOS dock applications..."
  dockutil --remove all
  for app in "${MACOS_DOCK_APPLICATIONS[@]}"; do
    dockutil --add "$app" --section apps
  done

  dockutil \
    --add "${HOME}/Downloads" \
    --view grid \
    --display folder \
    --sort dateadded \
    --section others
}

# :src/lib/setup/neovim_nightly.sh
py_neovim_packages=(
  "pynvim"
)

setup_neovim_nightly() {
  header "Setting up Neovim nightly..."
  git clone --depth=1 git@github.com:dhruvmanila/neovim.git "$NEOVIM_DIRECTORY"
  (
    cd "$NEOVIM_DIRECTORY" || exit 1
    git checkout master
    git remote add upstream git@github.com:neovim/neovim.git
    build_neovim
  )

  header "Setting up Neovim Python environment..."
  (
    cd ~/.neovim || exit 1
    python3 -m venv venv
    source venv/bin/activate
    pip3 install "${py_neovim_packages[*]}"
    deactivate
  )
}

# :src/lib/setup/npm_global_packages.sh
install_npm_global_packages() {
  header "Installing global npm packages from ${NPM_GLOBAL_PACKAGES}..."
  while IFS= read -r package; do
    npm --global install "$package"
  done < "${NPM_GLOBAL_PACKAGES}"
}

# :src/lib/setup/python.sh
# Setup the mentioned Python versions in from the constant $PYTHON_VERSIONS.
# The first element is made the global Python version.
#
# If the version is already installed, it will be skipped. `pip` will be
# upgraded for every mentioned version.
install_python() {
  for python_version in "${PYTHON_VERSIONS[@]}"; do
    if ! pyenv versions | grep -q "${python_version}"; then
      header "Installing Python ${python_version}..."
      pyenv install "${python_version}"
    else
      header "Python $python_version is already installed."
    fi
    header "Upgrading pip for Python ${python_version}..."
    "$(pyenv root)/versions/${python_version}/bin/pip" install --upgrade pip
  done

  pyenv_global_python="${PYTHON_VERSIONS[0]}"
  header "Making ${pyenv_global_python} as the global Python version..."
  pyenv global "${pyenv_global_python}"

  header "Initiating pyenv..."
  eval "$(pyenv init -)"
  eval "$(pyenv init --path)"

  header "Rehashing pyenv shims..."
  pyenv rehash
}

function install_global_python_packages() {
  header "Installing global Python packages from ${PYTHON_GLOBAL_REQUIREMENTS}..."
  while IFS= read -r package; do
    pipx install "$package"
  done < "${PYTHON_GLOBAL_REQUIREMENTS}"
}

# :src/lib/setup/symlinks.sh
declare -A symlinks

symlinks=(
  [".editorconfig"]=".editorconfig"
  ["assets/git/gitconfig"]=".gitconfig"
  ["assets/git/gitignore"]=".gitignore"
  ["assets/git/gitmessage"]=".gitmessage"
  ["assets/gpg/gpg-agent.conf"]=".gnupg/gpg-agent.conf"
  ["assets/gpg/gpg.conf"]=".gnupg/gpg.conf"
  ["assets/inputrc"]=".inputrc"
  ["assets/ssh/config"]=".ssh/config"
  ["bash/bash_profile"]=".bash_profile"
  ["bash/bashrc"]=".bashrc"
  ["config/bat"]=".config/bat"
  ["config/bottom"]="Library/Application Support/bottom"
  ["config/bpytop"]=".config/bpytop"
  ["config/glow"]="Library/Preferences/glow"
  ["config/htop"]=".config/htop"
  ["config/kitty"]=".config/kitty"
  ["config/nvim"]=".config/nvim"
  ["config/youtube-dl"]=".config/youtube-dl"
  ["mac/hammerspoon"]=".hammerspoon"
  ["mac/karabiner"]=".config/karabiner"
  ["python/flake8"]=".config/flake8"
  ["python/ipython/ipython_config.py"]=".ipython/profile_default/ipython_config.py"
  ["python/ipython/startup"]=".ipython/profile_default/startup"
  ["python/pip"]=".config/pip"
  ["python/pylintrc"]=".pylintrc"
  ["tmux/tmux.conf"]=".tmux.conf"
  ["vim"]=".vim"
  ["vim/vimrc"]=".vimrc"
  ["zsh/zprofile"]=".zprofile"
  ["zsh/zshenv"]=".zshenv"
  ["zsh/zshrc"]=".zshrc"
)

setup_symlinks() {
  # What does this file do? {{{
  #
  #   > Immediately after logging a user in, login displays the system copyright
  #   > notice, the date and time the user last logged in, the message of the day
  #   > as well as other information. If the file .hushlogin exists in the user's
  #   > home directory, all of these messages are suppressed.
  #
  # Source: `man login`
  # }}}
  if [[ ! -f "${HOME}/.hushlogin" ]]; then
    touch ~/.hushlogin
  fi

  # Create the necessary symbolic links between the `dotfiles` and `HOME` directory.
  header "Creating the necessary symlinks..."

  #                ┌ list associative array keys
  #                │
  for source in "${!symlinks[@]}"; do
    link "$source" "${symlinks[$source]}"
  done
}

# :src/lib/setup/tmux_plugins.sh
setup_tmux_plugins() {
  header "Installing tmux plugin manager..."
  git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm

  header "Installing tmux plugins..."
  ~/.tmux/plugins/tpm/bin/install_plugins
}

# :src/lib/setup/xcode_command_line_tools.sh
install_xcode_command_line_tools() {
  header "Installing xcode command line tools..."
  xcode-select --install
  # wait until the tools are installed...
  until xcode-select -p &> /dev/null; do
    sleep 5
  done
}

# :src/lib/upgrade/all.sh
upgrade_all() {
  upgrade_brew
  upgrade_plugins
  upgrade_packages
  upgrade_neovim_nightly
  upgrade_lua_language_server
}

# :src/lib/upgrade/brew.sh
upgrade_brew() {
  header "Updating homebrew..."
  brew update

  header "Upgrading homebrew packages..."
  brew upgrade

  header "Upgrading outdated casks..."
  brew upgrade --cask --greedy

  # Remove all cache files older than one day
  header "Cleaning up..."
  brew cleanup --prune 1
}

# :src/lib/upgrade/lua_lsp.sh
MAIN_BRANCH="master"

# https://github.com/sumneko/lua-language-server/wiki/Build-and-Run-(Standalone)
upgrade_lua_lsp() {
  header "Upgrading the lua language server to ${1:-"the latest commit on $MAIN_BRANCH"}..."
  (
    cd "$LUA_LANGUAGE_SERVER_DIRECTORY" || exit 1
    curr_hash=$(git rev-parse HEAD)

    # Pull the latest changes
    git checkout $MAIN_BRANCH
    git pull origin $MAIN_BRANCH
    git fetch origin --tags --force
    if [[ -n $1 ]]; then
      git checkout "$1"
    fi

    new_hash=$(git rev-parse HEAD)
    if [[ "$curr_hash" == "$new_hash" ]]; then
      seek_confirmation "Lua language server seems to be already up to date"
      if ! is_confirmed; then
        return
      fi
    fi

    build_lua_lsp
  )
}

# :src/lib/upgrade/neovim.sh
MAIN_BRANCH="master"

upgrade_neovim() {
  header "Upgrading Neovim to ${1:-"the latest commit on $MAIN_BRANCH"}..."

  (
    cd "$NEOVIM_DIRECTORY" || exit 1
    curr_hash=$(git rev-parse HEAD)

    # Pull the latest changes
    git checkout $MAIN_BRANCH
    git pull upstream $MAIN_BRANCH
    git push origin $MAIN_BRANCH
    git fetch upstream --tags --force
    if [[ -n $1 ]]; then
      git checkout "$1"
    fi

    new_hash=$(git rev-parse HEAD)
    if [[ "$curr_hash" == "$new_hash" ]]; then
      seek_confirmation "Neovim seems to be already up to date"
      if ! is_confirmed; then
        return
      fi
    fi

    build_neovim
  )
}

# :src/lib/upgrade/packages.sh
upgrade_packages() {
  for python_version in "${PYTHON_VERSIONS[@]}"; do
    header "Upgrading pip for Python $python_version..."
    "$(pyenv root)/versions/${python_version}/bin/pip" install --upgrade pip
  done

  header "Upgrading all pipx packages..."
  pipx upgrade-all

  header "Upgrading npm and packages..."
  npm --global install npm@latest
  npm --global upgrade
}

# :src/lib/upgrade/plugins.sh
upgrade_plugins() {
  # Not quiting vim/neovim to check what's new
  header "Upgrading vim plugins..."
  vim +PlugUpgrade +PlugClean +PlugUpdate

  header "Upgrading neovim plugins..."
  nvim +PackerSync

  header "Cleaning and updating tmux plugins..."
  ~/.tmux/plugins/tpm/bin/clean_plugins
  ~/.tmux/plugins/tpm/bin/update_plugins all
}

# :src/lib/utils.sh
ask() {
  yellow_bold "[?] $1"
  read -r -p "$(bold "> ")"
}

seek_confirmation() {
  if [[ -n $1 ]]; then
    warning "$1"
  fi
  read -r -p "$(bold "Continue? [y/n] ")" -n 1
  printf "\n"
}

is_confirmed() {
  [[ "$REPLY" =~ ^[Yy]$ ]]
}

is_git_repo() {
  git rev-parse --is-inside-work-tree &> /dev/null
}

command_exists() {
  command -v "$1" &> /dev/null
}

function_exists() {
  [[ "$(type -t "$1")" == "function" ]]
}

build_neovim() {
  make distclean
  make \
    CMAKE_BUILD_TYPE="${NEOVIM_BUILD_TYPE:-"Release"}" \
    CMAKE_EXTRA_FLAGS="-DCMAKE_INSTALL_PREFIX=$NEOVIM_INSTALL_DIRECTORY"
  make install
}

build_lua_lsp() {
  git submodule update --init --recursive
  cd 3rd/luamake || exit 1
  compile/install.sh
  cd ../..
  ./3rd/luamake/luamake rebuild
}

link() {
  local source_file="${DOTFILES_DIRECTORY}/${1}"
  local target_file="${HOME}/${2}"
  if ! [[ -e "$target_file" ]]; then
    echo "==> $target_file -> $source_file"
    ln -fs "$source_file" "$target_file"
  fi
}

setup_required_directories() {
  for directory in "${REQUIRED_DIRECTORIES[@]}"; do
    if ! [[ -d $directory ]]; then
      mkdir -p "$directory"
      if [[ -z $1 ]]; then
        echo "==> Created $directory"
      fi
    fi
  done
}

# :command.command_functions
# :command.function
dot_mac_command() {
  # :src/mac_command.sh
  # shellcheck disable=SC2154
  dock=${args[--dock]}
  settings=${args[--settings]}

  if [[ $dock ]]; then
    update_macos_dock
  fi

  if [[ $settings ]]; then
    seek_confirmation "This will override your macOS settings"
    if is_confirmed; then
      update_macos_settings
    fi
  fi
}

# :command.function
dot_link_command() {
  # :src/link_command.sh
  # shellcheck disable=SC2154
  force=${args[--force]}

  if ! [[ $force ]]; then
    declare -i count=0
    backup_dir="${HOME}/dotfiles_$(date +"%Y_%m_%dT%H_%M_%S").backup"
    mkdir "$backup_dir"

    for location in "${BACKUP_DOTFILES[@]}"; do
      if [[ -f $location || -d $location ]]; then
        cp -R "$location" "$backup_dir"
        ((count += 1))
      fi
    done

    if ((count > 0)); then
      header "Created backup in ${backup_dir}"
    else
      header "Skipped backup as there are no dotfiles"
      rm -rf "$backup_dir"
    fi
  fi

  setup_symlinks
}

# :command.function
dot_setup_command() {
  # :src/setup_command.sh
  seek_confirmation "'setup' command should only be invoked on a fresh setup"
  if ! is_confirmed; then
    exit
  fi

  setup_required_directories

  if ! [[ -d "$DOTFILES_DIRECTORY" ]]; then
    download_dotfiles
  fi

  header "Changing directory to $DOTFILES_DIRECTORY..."
  cd "$DOTFILES_DIRECTORY" || exit 1

  if ! xcode-select -p &> /dev/null; then
    install_xcode_command_line_tools
  fi

  if ! command_exists 'brew'; then
    install_homebrew
  fi
  install_homebrew_packages

  if ! is_git_repo; then
    setup_dotfiles_git_repository
  fi

  install_python
  install_global_python_packages
  install_global_npm_packages

  setup_neovim_nightly
  setup_lua_language_server

  # No backup as this is a fresh setup
  setup_symlinks

  setup_tmux_plugins
  setup_github_ssh

  update_macos_settings
  update_macos_dock
}

# :command.function
dot_sync_command() {
  # :src/sync_command.sh
  # shellcheck disable=SC2154
  sync_brew=${args[--brew]}
  sync_node=${args[--node]}
  sync_python=${args[--python]}

  # If there are no arguments, then the default behavior is to sync all files.
  if [[ -z ${args[*]} ]]; then
    sync_all=1
  fi

  if [[ $sync_all || $sync_brew ]]; then
    header "Syncing Brewfile with the currently installed packages..."
    HOMEBREW_NO_AUTO_UPDATE=1 brew bundle dump -f --describe
  fi

  if [[ $sync_all || $sync_python ]]; then
    header "Syncing requirements.txt with the global Python packages..."
    pipx list --json \
      | jq --raw-output '.venvs | keys | join("\n")' \
      | tee "${PYTHON_GLOBAL_REQUIREMENTS}" \
      | xargs -I{} echo "    {}"
  fi

  if [[ $sync_all || $sync_node ]]; then
    header "Syncing node_modules.txt with the global Node packages..."
    npm --global --json list \
      | jq --raw-output '.dependencies | del(."instant-markdown-d") | keys | join("\n")' \
      | tee "${NPM_GLOBAL_PACKAGES}" \
      | xargs -I{} echo "    {}"
  fi
}

# :command.function
dot_upgrade_command() {
  # :src/upgrade_command.sh
  # shellcheck disable=SC2154
  package="${args[package]}"
  ref="${args[--ref]}"
  handler="upgrade_$package"

  if function_exists "$handler"; then
    $handler "$ref"
  else
    error "Invalid package: $package"
    exit 1
  fi
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1

  case $action in
    -*) ;;

    \
      mac)
      action="mac"
      shift
      dot_mac_parse_requirements "$@"
      shift $#
      ;;

    link)
      action="link"
      shift
      dot_link_parse_requirements "$@"
      shift $#
      ;;

    setup)
      action="setup"
      shift
      dot_setup_parse_requirements "$@"
      shift $#
      ;;

    sync)
      action="sync"
      shift
      dot_sync_parse_requirements "$@"
      shift $#
      ;;

    upgrade)
      action="upgrade"
      shift
      dot_upgrade_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    *)
      dot_usage
      exit 1
      ;;

  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dot_mac_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_mac_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="mac"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --dock | -d)
        args[--dock]=1
        shift
        ;;

      # :flag.case
      --settings | -s)
        args[--settings]=1
        shift
        ;;

      \
        -*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dot_link_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_link_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="link"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)
        args[--force]=1
        shift
        ;;

      \
        -*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dot_setup_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_setup_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="setup"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dot_sync_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_sync_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="sync"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --brew | -b)
        args[--brew]=1
        shift
        ;;

      # :flag.case
      --node | -n)
        args[--node]=1
        shift
        ;;

      # :flag.case
      --python | -p)
        args[--python]=1
        shift
        ;;

      \
        -*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        printf "invalid argument: %s\n" "$key"
        exit 1
        ;;

    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
dot_upgrade_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
    --version | -v)
      version_command
      exit
      ;;

    --help | -h)
      long_usage=yes
      dot_upgrade_usage
      exit
      ;;

  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="upgrade"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ref | -r)
        if [[ $2 ]]; then
          args[--ref]="$2"
          shift
          shift
        else
          printf "%s\n" "--ref requires an argument: --ref, -r REF"
          exit 1
        fi
        ;;

      \
        -*)
        printf "invalid option: %s\n" "$key"
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        if [[ ! ${args[package]} ]]; then
          args[package]=$1
          shift
        else
          printf "invalid argument: %s\n" "$key"
          exit 1
        fi
        ;;

    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[package]} ]] || args[package]="all"
  # :command.whitelist_filter
  if [[ ! ${args[package]} =~ ^(all|brew|lua_lsp|neovim|packages|plugins)$ ]]; then
    printf "%s\n" "package must be one of: all, brew, lua_lsp, neovim, packages, plugins"
    exit 1
  fi
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
    printf "bash version 4 or higher is required\n"
    exit 1
  fi

  # :src/initialize.sh
  # shellcheck disable=SC2034
  #
  # Code here runs inside the `initialize()` function
  #
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  #
  #     > DOTFILES_DIRECTORY="${HOME}/dotfiles"
  #
  # Feel free to empty (but not delete) this file.

  case "$(uname)" in
    Darwin) ;;
    *)
      error "'dot' command is only supported on a mac machine"
      exit 1
      ;;
  esac

  DEFAULT_SHELL="bash"

  # Common directories
  DOTFILES_DIRECTORY="${HOME}/dotfiles"
  NEOVIM_DIRECTORY="${HOME}/contributing/neovim"
  NEOVIM_INSTALL_DIRECTORY="${HOME}/neovim"
  LUA_LANGUAGE_SERVER_DIRECTORY="${HOME}/git/lua-language-server"

  # Python versions to be installed on the system.
  # First version will be the global one
  PYTHON_VERSIONS=("3.9.6")

  # Packages file
  HOMEBREW_BUNDLE_FILE="${DOTFILES_DIRECTORY}/src/package/Brewfile"
  PYTHON_GLOBAL_REQUIREMENTS="${DOTFILES_DIRECTORY}/src/package/requirements.txt"
  NPM_GLOBAL_PACKAGES="${DOTFILES_DIRECTORY}/src/package/node_modules.txt"

  # On initialization of the script, if these directories does not exist, then
  # they will be created.
  REQUIRED_DIRECTORIES=(
    ~/.config
    ~/.gnupg
    ~/.ssh
    ~/contributing
    ~/git
    ~/neovim
    ~/playground
    ~/projects
    ~/work
  )

  # These files/directories will be backed up before symlinking, if they exists.
  # This step can be skipped if `-f/--force` flag is passed to the `link` command.
  BACKUP_DOTFILES=(
    ~/.bash_profile
    ~/.bashrc
    ~/.config
    ~/.gitconfig
    ~/.inputrc
    ~/.tmux.conf
    ~/.vim
  )

  # MacOS dock applications
  # Keep everything quoted due to spaces. Order: left to right
  MACOS_DOCK_APPLICATIONS=(
    "/Applications/Safari.app"
    "/Applications/Brave Browser.app"
    "/Applications/kitty.app"
    "/System/Applications/Notes.app"
    "/Applications/Mark Text.app"
    "/System/Applications/Music.app"
    "/System/Applications/Books.app"
    "/Applications/Slack.app"
    "/Applications/Discord.app"
    "/Applications/Docker.app"
  )

  setup_required_directories silent
}

# :command.run
run() {
  declare -A args
  declare -a other_args
  declare -a input
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "mac" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dot_mac_usage
    else
      dot_mac_command
    fi

  elif [[ $action == "link" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dot_link_usage
    else
      dot_link_command
    fi

  elif [[ $action == "setup" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dot_setup_usage
    else
      dot_setup_command
    fi

  elif [[ $action == "sync" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dot_sync_usage
    else
      dot_sync_command
    fi

  elif [[ $action == "upgrade" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      dot_upgrade_usage
    else
      dot_upgrade_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"

#!/usr/bin/env bash

# Open a CLI script in vim
# Mnemonic: (vi)m (w)hich
viw() {
  $EDITOR "$(which "$1")"
}

# Create a new directory and enter it
mcd() {
  mkdir -p "$@" && cd "$_" || return
}

# List out the bundle identifier of all the current dock applications.
# Used for `MACOS_DOCK_APPLICATIONS` in `~/dotfiles/src/initialize.sh`
dock-apps() {
  defaults read com.apple.dock persistent-apps \
    | rg --only-matching '\s*"_CFURLString" = "file://(.*)/";' --replace '"$1"' \
    | sed 's/%20/ /g'
}

# Upgrade the outdated Python packages for the current environment.
pip-upgrade() {
  python -m pip list --outdated \
    | awk 'NR>2 {print $1}' \
    | xargs python -m pip install --upgrade
}

# Uninstall all the Python packages for the current environment except for the
# ones already included when the environment was created.
pip-uninstall() {
  python -m pip list \
    | awk 'NR>2 {if ($1 != "pip" && $1 != "setuptools") print $1}' \
    | xargs python -m pip uninstall --yes
}

# Upgrade the Python version for the current virtual environment.
# NOTE: This assumes that we're using `pyenv` to install Python versions.
#
# $1 (string): upgrade to this version
py-upgrade-venv() {
  if [[ -z "$VIRTUAL_ENV" ]]; then
    echo "py-upgrade-venv: not in a virtual environment"
    return 1
  elif [[ -z "$1" ]]; then
    echo "Usage: py-upgrade-venv <version>"
    return 1
  fi
  python_exec="$(pyenv root)/versions/$1/bin/python"
  if [[ ! -e $python_exec ]]; then
    echo "py-upgrade-venv: version $1 does not exist"
    echo "py-upgrade-venv: Use 'pyenv install $1' to install it"
    return 1
  fi
  # The `--upgrade` flag assumes that Python was upgraded in place, so we need
  # to update the symlink to point to the desired Python version.
  echo "==> Updating the symlink..."
  ln -vsf "$python_exec" "$VIRTUAL_ENV/bin/python3"
  $python_exec -m venv --upgrade "$VIRTUAL_ENV"
}

# Create an IPython kernel for the current Python virtual environment.
# This is useful to have one Jupyter installation but different Python kernels
# for individual environments.
#
# $1 (string): name and display name of the kernal
py-kernel() {
  if [[ -z "$1" ]]; then
    echo "Usage: py-kernel <name>"
    return 1
  elif [[ -z "$VIRTUAL_ENV" ]]; then
    echo "py-kernel: not in a virtual environment"
    return 1
  fi
  python -m pip install --quiet ipykernel
  python -m ipykernel install --user --name "$1" --display-name "Python ($1)"
  echo "Use the 'Python ($1)' kernel for current venv in Jupyter"
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location.
o() {
  if [ $# -eq 0 ]; then
    open .
  else
    open "$@"
  fi
}

# nnn - Terminal file manager
n() {
  # Purpose: Avoid opening
  # Block nesting of nnn in subshells
  if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
    echo "nnn is already running"
    return
  fi

  # The default behaviour is to cd on quit (nnn checks if NNN_TMPFILE is set)
  # To cd on quit only on ^G, remove the "export" as in:
  #
  #     export NNN_TMPFILE="${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd"
  #     ^----^
  #
  # NOTE: NNN_TMPFILE is fixed, should not be modified
  local NNN_TMPFILE="${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd"

  nnn "$@"

  if [ -f "$NNN_TMPFILE" ]; then
    . "$NNN_TMPFILE"
    rm -f "$NNN_TMPFILE" > /dev/null
  fi
}
